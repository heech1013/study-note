# Web

## Table of Contents

네트워크

- 주소창에 'www.naver.com'을 입력 후 접속했을 때의 무슨 일이 일어날까?

브라우저

- 브라우저의 렌더링 과정에 대해 설명?
- 레이아웃과 리페인트의 차이점은?
- 레이아웃과 리페인트의 성능상 차이점은?
- DOM이란?
- DOM의 개체 구조에 대해 설명?
- DOM은 HTML과 1:1로 매핑되는가?
- HTML 문서에서 script 파일을 어디에 위치시키는 것이 좋을까?
- 스크립트 로딩이 HTML 파싱을 방해하는 이유는?
- script를 body 태그 최하위에 놓는 것의 한계는? 그 대안은?
- script 태그의 defer 속성에 대해 설명?
- 여러 defer script 간 script가 실행되는 순서는?
- defer script를 사용할 때 주의해야 할 점은?
- script 태그의 async 속성에 대해 설명?
- 여러 async script 간 script가 실행되는 순서는?
- defer script와 async script가 각각 어느 경우에 유용한가?

성능

- 웹에서 서비스의 성능을 측정하는 방법은?
- 브라우저에서 DOMContentLoaded와 load 이벤트가 발생하는 시점은?
- 브라우저에서 이벤트가 발생하는 시점을 측정하는 방법은?
- 브라우저 기준으로 성능을 측정하는 것의 한계(단점)은?
- 사용자 기준에서 성능을 측정할 수 있는 지표들에 대해 아는 것이 있는지?
- 사용자 기준에서 성능을 측정하는 방법은?
- 웹 페이지 로딩을 최적화할 수 있는 방법에는 어떤 것들이 있을까?
- 블록 리소스 최적화에 대해 설명?
- 리소스 요청 수 줄이기에 대해 설명?
- 리소스 용량 줄이기에 대해 설명?
- 웹 페이지 렌더링을 최적화할 수 있는 방법에는 어떤 것들이 있을까?
- 레이아웃 최적화에 대해 설명?
- 애니메이션 최적화에 대해 설명?

HTTP

- HTTP란?
- HTTP의 특징?
- HTTP가 비연결성으로 설계된 이유가 뭘까?
- HTTP의 비연결성으로 인한 단점이 뭐가 있을까?
- HTTP의 비연결성을 해결하기 위한 방법?
- Keep-Alive를 사용하는 방법?
- Keep-Alive의 장점?
- Keep-Alive의 단점?
- 무상태성을 해결하기 위한 방법?
- HTTP 요청/응답 메시지의 구성(형식)은?
- HTTP Method에는 어떤 것들이 있나?
- GET과 POST의 차이?
- 멱등성이란?
- GET과 HEAD의 차이?
- POST와 PUT의 차이?
- PUT와 PATCH의 차이?
- OPTIONS 란?
- OPTIONS가 언제 사용될까?
- CORS의 preflight request의 목적은?
- (참고) 주요 HTTP 응답 코드
- 인증과 인가의 차이점은?
- HTTP 헤더 중 알고 있는 헤더가 뭐가 있나요?
- HTTP의 보안 취약점은?

HTTPS

- HTTPS란?
- HTTPS를 통해 얻을 수 있는 이점은?
- HTTPS가 암호화 채널을 수립할 때 사용하는 암호화 프로토콜은?
- SSL 인증서란?
- SSL 인증서의 역할은?
- SSL 인증서에 포함된 정보는?
- SSL 인증서가 서비스를 보증하는 과정은?
- SSL 통신 과정을 설명해본다면?

HTTP/2

- HTTP/2 이전 버전들의 성능 제한 이슈는? (HTTP/2가 등장한 이유는?)
- HTTP/2의 목적은?
- HTTP/2가 제공하는 주요 기능에는 어떤 것들이 있나?
- HTTP/2는 HTTP의 의미 체계를 대체(변경)하는지?
- HTTP/2의 바이너리 프레이밍 계층이란?
- HTTP/2의 스트림, 메시지, 프레임에 대해 설명?
- HTTP/2가 요청, 응답 다중화를 지원하는 원리는?
- HTTP/2의 요청, 응답 다중화를 통해 얻을 수 있는 이점은?
- HTTP/2의 (출처당) 단일 연결을 통해 얻을 수 있는 이점은?
- HTTP/2에서 스트림 우선순위를 지정하는 과정은?
- HTTP/2의 서버 푸시에 대해 설명?
- HTTP/2의 헤더 압축에 대해 설명?

쿠키 & 세션

- 쿠키란?
- 쿠키는 어떻게 구성되어 있나?
- 쿠키를 생성하는 방법은?
- 쿠키를 요청 메시지에 어떻게 설정하나?
- 요청 메시지에 쿠키가 어디에 들어가있나?
- 쿠키의 단점은?
- 쿠키의 성능 상 단점을 보완하기 위한 대안은?
- 쿠키의 보안적 취약점?
- 쿠키의 보안적 취약점에 대한 대안은?
- 쿠키가 만료되는 시점은?
- 세션이란?
- 세션을 생성하는 절차는?
- 세션의 데이터가 유지되는 기간은? (만료되는 시점은?)
- 쿠키와 세션의 차이점?
- 세션의 장점에도 불구하고 쿠키를 사용하는 이유?

localStorage & sessionStorage

- localStorage(또는 sessionStorage)란?
- 쿠키 대신 사용하는 이유는?
- localStorage과 sessionStorage의 차이점은?

CORS

- CORS란?
- origin(출처)이란?
- 같은 출처, 다른 출처를 판단하는 기준은?
- SOP(동일 출처 정책)란?
- SOP가 존재하는 이유는?
- SOP가 교차 출처로 삽입하는 리소스를 허용하는 경우는?
- 브라우저와 서버 중 CORS를 판단하는 주체는?
- CORS가 동작하는 방식은? (브라우저가 CORS를 판단하는 방법은?)
- CORS가 동작하는 세 가지 시나리오에 대해 알고 있는지?
- Simple Request란? (+ 과정을 설명해본다면?)
- Simple Request를 사용할 수 있는 조건은?
- Preflight Request란? (+ 과정을 설명해본다면?)
- Credentialed Request란?
- Credentialed Request를 사용하는 방법은?
- credentials에 옵션이 same-origin(그리고 같은 출처 간 통신일 때)이거나 include일 때 브라우저가 추가로 확인하는 조건은?
- CORS를 해결할 수 있는 방법은?
- 프록시 서버를 활용해 CORS 에러를 해결하는 과정은?
- CORS(혹은 Access-Control-Allow-Origin)의 단점?
- JSONP란?
- JSONP를 활용하는(동작하는) 과정에 대해 설명?
- JSONP가 더 이상 사용되지 않는 이유는?

REST

- REST란?
- REST의 특징은?
- Uniform Interface란? (더 자세히 설명?)
- Uniform Interface가 필요한 이유는 뭘까?
- REST의 구성은?
- REST에서 정의하는 CRUD Operation과 그에 해당하는 HTTP Method는?
- REST의 장단점?
- REST API란?
- REST API의 규칙은?

보안 공격(XSS/CSRF/SQL Injection)

- XSS란?
- XSS를 방지하기 위한 방법은?
- CSRF란?
- CSRF를 방지하기 위한 방법은?
- SQL Injection이란?
- SQL Injection 중 아는 종류가 있는지?
- SQL injection의 대응 방안은?

Web Server & WAS

- Static Page와 Dynamic Page의 차이점은?
- 웹 서버란?
- 웹 서버의 기능은?
- WAS(Web Application Server)란?
- WAS의 기능은?
- 웹 서버가 필요한 이유는?
- WAS가 필요한 이유는?
- WAS로 웹 서버와 애플리케이션 서버 기능을 모두 수행하지 않는 이유는?

CSR / SSR / SPA

- CSR이란?
- SSR이란?
- SSR의 장점?
- SSR의 단점?
- SPA란?
- 전통적인 웹 방식은 어땠나?
- SPA의 장점?
- SPA의 단점?
- SPA를 하면 SEO에 문제가 생기는 이유?
- SPA의 단점 - 초기 구동 속도를 극복하기 위한 방법?
- SPA의 단점 - SEO 최적화 문제를 극복하기 위한 방법?
- Routing이란?
- SPA에서 routing이 어려울 수 있는 이유?

프론트엔드 개발의 흐름과 철학

- 단방향 바인딩과 양방향 바인딩의 차이는?
- 양방향 데이터 바인딩의 장단점은?
- 단방향 데이터 바인딩의 장단점은?
- (참고) 데이터 상태 관리의 흐름에 대하여

Ajax

- Ajax란?
- Ajax의 이점? 사용 이유?
- Ajax를 사용하는 방법은? Ajax가 동작하는 원리는?

JSON

- JSON이란?
- 다른 데이터 포맷과 비교하여 JSON의 이점?
- JavaScript 객체를 JSON으로 변환하는 방법은? 그 반대는?

기타

- URI와 URL의 차이는?
- 웹 접근성(Web Accessibility)
- HTML5

## 네트워크

### 주소창에 'www.naver.com'을 입력 후 접속했을 때의 무슨 일이 일어날까?

사용자가 브라우저의 URL 주소창에 주소를 입력하고 접속하면,

브라우저는 URL 주소 중 domain name에 해당하는 부분을 DNS에 검색한다.

- DNS 서버는 해당 도메인 네임에 해당하는 IP 주소를 브라우저에게 응답한다.

브라우저는 IP주소로 HTTP 프로토콜을 사용해 HTTP 요청 메시지를 생성한다.

- 생성된 요청 메시지는 TCP/IP 프로토콜을 통해 해당 IP주소를 가지는 컴퓨터로 전송된다.
- 도착한 메시지는 HTTP 프로토콜로 인해 URL 정보로 변환된다.

웹 서버는 URL 정보에 해당하는 정보를 검색한다.

- 찾은 정보를 HTTP 프로토콜을 사용해 응답 메시지로 생성한다.
- 생성된 HTTP 응답 메시지는 TCP/IP 프로토콜을 통해 요청을 보냈던 컴퓨터로 전송된다.

도착한 HTTP 응답 메시지는 HTTP 프로토콜을 통해 웹 페이지 데이터로 변환된다.

- 브라우저는 웹 페이지 데이터를 파싱해서 렌더링한다.

## 브라우저

### 브라우저의 렌더링 과정에 대해 설명?

1. 파싱

- 렌더링 엔진은 HTML 문서를 파싱해 DOM 트리를 구축한다.

  > - (브라우저 렌더링 과정의) 파싱 : 브라우저가 코드를 자신이 이해할 수 있는 구조로 변환하는 것.
  > - 렌더링 엔진 : 요청 받은 내용을 브라우저 화면에 표시하는 일을 하는 엔진. Gecko 엔진, Webkit 엔진 등이 있다.

- CSS를 파싱 후 CSSOM(CSS Object Model) 트리를 구축한다.

2. 스타일

- DOM 트리와 CSSOM 트리를 결합해 '렌더 트리'를 생성한다.

  > - `visibility: hidden;` 속성은 화면에서 보이지 않지만, 공간을 차지하므로 렌더 트리 내에 구축된다.
  > - `display:none;` 속성은 화면에서 보이지도 않고, 공간도 차지하지 않아 렌더 트리 내에 구축되지 않는다.
  >
  > - 브라우저 로딩 과정 중 '렌더링'은 스타일 이후의 과정(스타일→레이아웃→페인트→합성)을 말한다.

3. layout

- 렌더 트리 생성이 끝나면, 각 노드의 화면 상 정확한 위치와 크기를 px로 계산하는 layout 작업을 시작한다.

  > 배치, 리플로우(reflow)라고도 불림. 각기 다른 브라우저에서 사용되지만 같은 행동을 가리키는 표현.

4. paint

- 렌더 트리의 각 노드를 화면 상의 실제 px로 변환함

  > - px로 변환된 결과는 'layer'의 형태로 관리된다.

5. 합성 & 렌더

- paint 단계에서 생성된 레이어를 합성해 스크린을 업데이트한다.

> - UI 백엔드 : 창 같은 기본적인 장치를 그리는 인터페이스.
>
> - 위 과정은 점진적으로 진행된다. 모든 HTML 파싱이 끝날 때까지 기다리지 않고 레이아웃과 페인트 작업을 시작한다.
> - 브라우저가 렌더링하는 과정을 Critical Rendering Path(CRP)라고 부른다.

---

### 레이아웃과 리페인트의 차이점은?

레이아웃

- 자바스크립트에 의해 DOM tree, CSSOM tree가 변경될 때 렌더 트리가 재구성된다.
- 이때, 레이아웃 이후 과정을 다시 수행하는데 이를 레이아웃(또는 리플로우)이라고 부른다(부르기도 한다).

  `(JavaScript) > Style > Layout > Paint > Composite`

> - DOM이 추가/삭제되거나, 기하적인 영향을 주는 CSS 속성값(넓이, 높이, 위치 등)을 변경하는 경우 레이아웃이 발생한다.

리페인트

- 기하적인 영향을 주지 않는 CSS 속성값을 변경할 시 레이아웃 과정을 건너뛰고 페인트 이후 과정을 수행한다. 이를 리페인트라고 부른다(부르기도 한다).

  `(JavaScript) > Style >~~Layout~~> Paint > Composite`

---

### 레이아웃과 리페인트의 성능상 차이점은?

- 레이아웃이 발생하면 전체 픽셀을 다시 계산해야 하므로 부하가 크다.
- 리페인트는 이미 계산된 픽셀값으로 화면을 그리기 때문에 부하가 적다.

> - 기하적 영향을 주는 CSS 속성값: `height`, `width`, `left`, `top` 등
> - 기하적 영향을 주지 않는 CSS 속성값: `background-color`, `visibility` 등

---

### DOM이란?

웹 페이지에 대한 인터페이스.

- 문서에 대한 구조화된 (객체 기반의) 표현을 제공.
- 프로그래밍 언어가 DOM 구조에 접근할 수 있는 방법 제공.

---

### DOM의 개체 구조에 대해 설명?

DOM은 노드 트리로 구성된다.

- 루트 요소는 `<html>`
- 루트 요소에 포함된 자식 줄기는 `<html>`에 포함된 태그들
- 리프 요소는 태그 안에 포함된 컨텐츠들

---

### DOM은 HTML과 1:1로 매핑되는가?

(HTML로부터 DOM이 형성되지만) DOM과 HTML은 1:1로 매칭되지 않는다. 다음과 같은 경우에-

1. 작성한 HTML 문서가 유효하지 않을 때

- (예) 유효한 HTML의 필수 사항(`<head>`, `<body>` 등)이 빠져 있을 때, 닫는 태그 없이 작성했을 때, 브라우저는 HTML 코드를 교정해 DOM을 생성한다.

2. 작성한 HTML 문서가 브라우저에 보이지 않을 때

- 실제 브라우저에 보이는 것은 HTML이 아니라, DOM과 CSSOM의 조합인 렌더 트리이다. `display: none;` 등의 스타일이 결합되었을 때 HTML에 존재하는 요소가 DOM에는 존재하지 않을 수 있다.

3. JavaScript에 의해 DOM이 수정될 때

- HTML에는 없는 요소가 JavaScript에 의해 새로 추가되어 DOM에 나타날 수 있다. 하지만 그것이 HTML 원문을 수정하지는 않는다.

---

### HTML 문서에서 script 파일을 어디에 위치시키는 것이 좋을까?

`<body>` 태그 내부의 가장 아래에 위치시키는 것이 좋다.

그 이유는,

- HTML 요소들이 렌더링 될 때 스크립트 로딩으로 인해 지연되지 않아 웹페이지 로딩 시간이 단축된다.
- DOM이 완성되지 않은 상태에서 자바스크립트가 DOM을 조작해 에러가 발생하는 것을 방지할 수 있다.

> - script는 script 아래에 있는 DOM 요소에 접근할 수 없다.

---

### 스크립트 로딩이 HTML 파싱을 방해하는 이유는?

- 자바스크립트는 렌더링 엔진이 아니라 자바스크립트 엔진이 처리한다.
- HTML 파서는 `<script>` 태그를 만나면 자바스크립트 코드를 다운 받고, 실행하기 위해 DOM 생성 프로세스를 멈추고 자바스크립트 엔진으로 제어권을 넘겨준다. (스크립트를 로드할 때부터 파싱이 중단됨)
- 자바스크립트 실행이 완료되면 HTML 파서로 제어권을 다시 넘겨 DOM 생성을 재개한다.

> - `<script>`의 경우 script를 실행하는 동안 파싱을 멈춘다. (src 속성이 있는) 외부 script의 경우 script를 다운 받고, 실행하는 동안 파싱을 멈춘다.
> - 브라우저는 HTML과 CSS, JavaScript를 동기적으로 처리한다.

---

### script를 body 태그 최하위에 놓는 것의 한계는? 그 대안은?

HTML 문서 자체가 아주 큰 경우, 브라우저는 HTML 문서를 모두 다운 받고 스크립트를 다운 받으므로 페이지가 매우 느려질 것이다.

- 대안으로, `<script>`의 `defer`, `async` 속성이 있다.

---

### script 태그의 defer 속성에 대해 설명?

- 브라우저는 defer 스크립트('지연 스크립트')를 백그라운드에서 다운 받는다.
- defer 스크립트의 실행은 페이지 구성이 끝날 때까지 지연된다.

> - `DOMContentLoaded`: 초기 HTML 문서를 불러오고 분석했을 때(DOM tree가 완성됐을 때) 발생하는 이벤트

> - `defer` 속성은 외부 스크립트(`src` 속성이 있는 script)에만 유효하다.

---

### 여러 defer script 간 script가 실행되는 순서는?

HTML에 추가된 순서대로 실행된다.

> - 단, 길이가 짧은 스크립트가 먼저 다운로드가 완료된다. (실행은 순서대로 되더라도)
> - 브라우저는 성능을 위해 어떤 스크립트가 있는지 확인한 후, 스크립트를 병렬적으로 다운로드하기 때문이다.

---

### defer script를 사용할 때 주의해야 할 점은?

스크립트가 실행되기 전에 페이지가 화면에 출력된다는 점에 주의해야 한다.

- 스크립트를 통해 준비가 되지 않은 DOM에 사용자가 접근할 수 있다.

→ defer 스크립트가 영향을 주는 영역에 loading indicator, 혹은 disable 처리가 있어야 한다.

> - ES6 module은 자동으로 `defer` 속성이 적용된다.  
>   ex) `<script type="module" src="./main.js"></script>`

---

### script 태그의 async 속성에 대해 설명?

- async 스크립트('비동기 스크립트')는 백그라운드에서 다운로드 된다.
- async 스크립트가 실행될 때는 HTML 파싱이 멈춘다.

> - `DOMContentLoaded` 이벤트와 async 스크립트는 서로를 기다리지 않는다.

---

### 여러 async script 간 script가 실행되는 순서는?

- async 스크립트는 다운로드 된 순서대로 실행된다.
- async 스크립트들은 서로를 기다리지 않는다.

> - 먼저 다운로드 된 스크립트가 먼저 실행되는 특성을 'load-first order'라고 칭한다.

---

### defer script와 async script가 각각 어느 경우에 유용한가?

defer script

- DOM 전체가 필요한 스크립트이거나 실행 순서가 중요한 스크립트일 때. (DOM이 모두 준비된 후, 그리고 추가한 스크립트 순서대로 실행되기 때문이다.)

async script

- 방문자 수 카운터나 광고 관련 스크립트 등 각각 독립적인 역할을 하는 스크립트를 삽일할 때. (async script와 개발 중인 script가 서로에게 의존적이지 않기 때문이다.)

**(참고)**

![Web%20a8bd6cb86f15403fa6e62833f6c3d9f2/Untitled.png](Web%20a8bd6cb86f15403fa6e62833f6c3d9f2/Untitled.png)

![Web%20a8bd6cb86f15403fa6e62833f6c3d9f2/Untitled%201.png](Web%20a8bd6cb86f15403fa6e62833f6c3d9f2/Untitled%201.png)

## 성능

### 웹에서 서비스의 성능을 측정하는 방법은?

브라우저 기준으로 측정할 수도 있고, 사용자 기준으로 측정할 수도 있다.

브라우저 기준

- 브라우저에서 발생하는 `DOMContentLoaded`, `load` 등의 이벤트가 발생하는 시점으로 판단.

사용자 기준

- 사용자에게 컨텐츠를 보여주는 여러 시점을 기반으로 성능을 측정하는 방법.
- 의미 있는 컨텐츠가 처음 보이는 시점이 빠를 수록 성능이 좋다고 판단한다.
  (즉, FMP를 앞당겨야 한다.)

---

### 브라우저에서 DOMContentLoaded와 load 이벤트가 발생하는 시점은?

`DOMContentLoaded`

- HTML과 CSS 파싱이 끝나는 지점
  즉, 렌더 트리를 구성할 준비를 마친 상황.

`load`

- 문서 상에 필요한 모든 리소스가 로드된 시점.

---

### 브라우저에서 이벤트가 발생하는 시점을 측정하는 방법은?

크롬 개발자 도구의 Network 탭에서 두 이벤트 `DOMContentLoaded`와 `load`를 확인할 수 있다.

> - `DOMContentLoaded`와 `load`의 발생 시점이 빠를수록, 그리고 둘 사이의 폭이 좁을수록 성능이 좋다고 말한다.

---

### 브라우저 기준으로 성능을 측정하는 것의 한계(단점)은?

SPA의 경우, 웹 페이지에 적은 양의 HTML이 포함되어 DOMContentLoaded와 load가 일찍 발생할 수 있으나, 이벤트가 발생한 이후에도 많은 스크립트 실행으로 인해 느린 로딩이 존재할 수 있다.
(이러한 이유로 사용자 기준의 성능 측정 방식이 필요하게 되었다.)

---

### 사용자 기준에서 성능을 측정할 수 있는 지표들에 대해 아는 것이 있는지?

- First Paint: 흰 화면에서 무언가가 처음으로 그려지기 시작하는 순간
- First Contentful Paint: 텍스트나 이미지가 출력되기 시작하는 순간
- First Meaningful Paint: 사용자에게 의미 있는 컨텐츠가 그려지기 시작하는 순간.
  (CSS, JavaScript 로드가 시작되고 스타일이 적용되는 시기)
- Time to Interactive: JavaScript 초기 실행이 완료되어 사용자가 직접 행동을 취할 수 있는 순간.

---

### 사용자 기준에서 성능을 측정하는 방법은?

크롬의 경우 크롬 개발자 도구의 Network, Performance, Lighthouse(Audits) 탭을 활용할 수 있다.

- Performance: 웹 페이지 로딩 단계를 차트 형태로 살펴볼 수 있다.
- Network: 웹 페이지가 로딩되는 동안 요청되는 리소스의 상태를 살펴볼 수 있다.
- Lighthouse: 사용자 기준의 성능 측정 지표를 확인할 수 있다.

> Performance
>
> - 녹화를 시작하고, 페이지를 로딩시킨 후 Profiling하면 분석된 자료를 확인할 수 있다.
> - 브라우저 로딩 과정에서 Script, Layout, Paint 등을 확인할 수 있다.
>
> Network
>
> - 각 리소스에 마우스를 오버하면 서버 요청 대기 시간 관련 세부 항목들을 확인할 수 있다.
>   - Queuing: 대기열에 쌓아두는 시간
>   - Stalled: 요청 보내기 전 대기 시간
>   - DNS Lookup: DNS 조회에 소비된 시간
>   - Initial connection: TCP handshake & SSL을 포함한 연결에 걸린 시간
>   - Waiting(TTFB, Time To First Byte): 초기 응답을 기다리는 데 걸린 시간
>   - Content Download: 리소스 실제 다운로드 시간
>
> Lighthouse
>
> - 크게 Performance, Accessibility, Best Practices, ~~SEO~~ 등의 항목에 대해 측정
> - Performance의 측정 metrics로 FCP, FMP, TTI 등이 있음.
> - Opportunities에 페이지 로드를 앞당길 수도 있는 항목들에 대해 추천함(ex: Remove unused CSS)
> - Accessibility의 측정 metrics로 Contrast, Names and labels 등이 있음.

---

### 웹 페이지 로딩을 최적화할 수 있는 방법에는 어떤 것들이 있을까?

- 블록 리소스 최적화
- 리소스 요청 수 줄이기
- 리소스 용량 줄이기

---

### 블록 리소스 최적화에 대해 설명?

> - 브라우저 로딩 단계에서, HTML 파싱 중 CSS와 JavaScript로 인해 파싱이 중단될 수 있다.  
>   (→ "HTML 파싱이 블록되었다")  
>   (블록 원인이 되는 리소스 → "블록 리소스")

CSS 최적화

1. CSS를 HTML 문서 최상단(`<head>` 아래)에 위치시킨다.

   - 렌더 트리 = DOM tree + CSSOM tree  
     DOM tree는 파싱 중 태그를 만날 때마다 순차적으로 구성할 수 있지만, CSSOM tree는 CSS를 모두 해석해야 구성할 수 있다. 때문에 CSSOM tree가 구성되지 않으면 렌더 트리를 만들지 못하고 렌더링이 차단된다.  
     (이러한 이유로, CSS는 '렌더링 차단 소스'로 간주된다.)

2. 특정 조건에서만 필요한 CSS의 경우 미디어 쿼리를 사용해 조건적으로 리소스를 다운 받는다.

```html
<head>
  <link href="style1.css" rel="stylesheet" />
  <link href="style2.css" rel="stylesheet" media="print" />
  <!-- media="print" : 페이지를 인쇄할 때 -->
</head>
```

> - `<link>`: 현재 문서와 외부 리소스와의 관계를 명시.
> - `rel`: 현재 문서와, 연결된 아이템의 관계를 명시. CSS는 "stylesheet"로 명시.

JavaScript 최적화

1. `<script>`를 HTML 문서 최하단(`</body>` 직전)에 위치시킨다.

   - DOM tree 생성 중 `<script>`를 만나면 DOM tree 생성이 중단된다.  
     (이러한 이유로, JavaScript도 '렌더링 차단 소스'로 간주된다.)

2. `<script>`에 `async`나 `defer` 속성을 명시해서 script를 다운 받는 동안에 브라우저가 파싱을 멈추지 않도록 조치한다.

---

### 리소스 요청 수 줄이기에 대해 설명?

1. 이미지 스프라이트

   - 여러 개의 이미지를 하나로 만들고, CSS의 `background-position` 속성을 사용해 부분 이미지를 사용하는 방법.

2. CSS, JavaScript 번들하기

   - webpack 등의 번들러를 사용해 여러 개의 CSS, JavaScript 파일을 '번들 파일'로 만든다.

---

### 리소스 용량 줄이기에 대해 설명?

(여러 방법 중 하나:) 압축(minify)하여 사용하기

- HTML, CSS, JavaScript 모두 압축해 사용할 수 있다.
- 불필요한 주석이나 공백 등을 제거한 후 난독화해 사용한다.
- webpack plugin 등으로 처리할 수 있다.

---

### 웹 페이지 렌더링을 최적화할 수 있는 방법에는 어떤 것들이 있을까?

> - 렌더링은 JavaScript의 실행시간과, JavaScript로 인해 DOM, CSS가 변경되어 화면에 다시 그리는 시간을 포함한다.
> - 웹 페이지에는 JavaScript가 많이 사용되며, 브라우저의 JavaScript 엔진은 싱글 스레드로 동작하기 때문에 JavaScript 실행시간은 렌더링 성능과 직결된다.

- 레이아웃 최적화
- 애니메이션 최적화

---

### 레이아웃 최적화에 대해 설명?

> 레이아웃 최적화의 목표는
>
> - JavaScript 실행 과정을 단축하고,
> - 렌더링이 다시 일어나는 과정에서 레이아웃에 걸리는 시간을 단축하고,
> - 레이아웃이 최대한 발생하지 않도록(리페인트만 발생하도록) 하는 것이다.

1. 강제 동기 레이아웃 피하기

> - 원래 레이아웃은 비동기로 동작한다.
> - 강제 동기 레이아웃은 JavaScript 실행 시간을 증가시킨다.

- 스타일을 변경한 후, 계산된 값(`offsetHeight` 등)을 속성으로 읽을 때 강제 동기 레이아웃이 발생한다.

  > - 반복문 등을 통해 강제 동기 레이아웃이 연속으로 발생하는 경우 성능이 더욱 저하되는데, 이를 '레이아웃 스레싱(layout thrashing)'이라고 한다. 반복문 밖에서 계산된 값을 읽어 변수로 사용하면 이를 막을 수 있다.

2. 숨겨진 엘리먼트를 수정

- 많은 수의 엘리먼트를 변경해야 할 경우, `display: none;` 스타일이 적용된 채로 변경하고 다시 보이도록 해 레이아웃의 발생을 줄일 수 있다.

  > - `visibility: hidden;`은 보이지 않아 리페인트가 발생하지는 않지만, 공간은 차지하므로 레이아웃이 발생한다.

---

### 애니메이션 최적화에 대해 설명?

- 한 프레임의 처리가 16ms(60fps) 내로 완료되어야 끊기는 현상 없이 자연스러운 렌더링을 구현할 수 있다.

  > - 프레임: 애니메이션 혹은 동영상을 구성하는 정지된 화면
  > - fps: frames per second(단위)

  1. `position: absolute;` (or) `fixed;` 처리

  - 애니메이션이 주변 영역의 레이아웃에 영향을 주지 않도록 한다.

    > - `position`: 문서 상에 요소를 배치하는 방법을 지정한다.
    > - `absolute`: 요소를 일반적인 문서 흐름에서 제거, 레이아웃에 공간을 배정하지도 않는다. 대신 가장 가까운 조상 요소에 상대적으로 배치한다. 위치는 `top`, `right`, `bottom`, `left`가 지정한다.
    > - `fixed`: 요소를 일반적인 문서 흐름에서 제거, 레이아웃에 공간을 배정하지도 않는다. 대신 뷰포트의 초기 컨테이너 블록을 기준 삼아 배치한다.
    > - 뷰포트(viewport): 현재 화면에 보여지고 있는 직사각형 영역. 현재 창에서 볼 수 있는 영역.

  2. `transform` 사용

  - `tansform`을 사용하는 엘리먼트는 레이어로부터 분리되어 영향 받는 엘리먼트가 제한된다.
  - 레이아웃과 페인트를 줄일 수 있다. (합성만 발생)

    (`position`, `width`, `height` 등은 기하적 변화를 유발하며, 레이아웃이 발생한다.)

  > - `transform`: 요소에 회전(`rotate()`), 크기 조절(`scale()`), 이동 효과(`translate()`) 등을 부여할 수 있다.

## HTTP

### HTTP란?

hypertext를 주고 받기 위한 통신 프로토콜.

> - 프로토콜: 양식과 규칙 체계.
> - 통신 프로토콜 : 통신 장비 사이에서 메시지를 주고 받기 위한 양식과 규칙 체계.
> - hypertext: hyperlink를 통해 한 문서에서 다른 문서로 즉시 접근할 수 있는 텍스트.

---

### HTTP의 특징?

비연결성(connectionless) 프로토콜이다.

- 클라이언트와 서버가 연결을 맺은 후, 클라이언트의 요청에 대해 서버가 응답을 마치면 연결을 바로 끊어버리는 성질을 말한다.

무상태(stateless) 프로토콜이다.

- 클라이언트와 서버가 통신 후 연결을 끊는 순간, 서버는 클라이언트에 대한 상태 정보를 유지하지 않는다.
  (→ 서버는 접속하는 클라이언트의 상태를 알 수 없다, 식별할 수 없다.)

> 기타 특징
>
> - HTTP는 클라이언트-서버 모델을 따른다: 클라이언트가 요청을 생성하기 위한 연결을 연 다음, 서버로부터 응답을 받을 때까지 기다린다.

> HTTP의 비연결성(connectionless)에 대하여..
>
> - HTTP의 하위 레이어 프로토콜인 TCP는 연결형(connection-oriented) 프로토콜이다.
> - TCP에서는 클라이언트로부터 SYN 패킷이 도착하면, 서버는 buffer를 할당해 해당 connection에 대한 정보를 기록한다. 이로 인해, 특정 패킷이 순서에서 벗어나면 호스트는 buffer를 사용해 순서를 정돈할 수 있다. (FIN 패킷을 통해 양측 호스트는 연결을 해제하고 buffer 등의 자원을 해제한다.)
> - 즉, 호스트의 buffer와 TCP/IP 패킷은 source IP, port, destination IP, port, Sequence Number로 connection 상태를 유지한다.
>
> - 그러나 HTTP는 패킷 내부에 이러한 connection history를 유지할 수 있는 어떠한 identifier도 가지고 있지 않다.
> - 특정 layer 모듈의 연결성이 다른 layer 모듈의 연결성을 강제하는 것은 아니다. (즉, TCP가 connection-oriented라 해서 HTTP가 connection-oriented여야 할 이유는 없다)

> TCP의 connection-oriented와 HTTP의 connectionless  
> HTTP: 연결 → request → response → 연결 해제  
> TCP/IP: application layer의 데이터 → TCP, IP layer에서 패킷 분할 → 분할된 패킷 전송 간 connection, buffer 등 연결에 대한 history를 유지하며 순서, 오류 제어 등을 지원

---

### HTTP가 비연결성으로 설계된 이유가 뭘까?

- 클라이언트와의 연결을 유지하기 위해서는 여러 자원이 사용된다.
- HTTP는 인터넷 상 불특정 다수와의 통신을 기반으로 설계되었기 때문에, 연결을 유지하지 않고 대신 해당 리소스로 더 많은 클라이언트와 연결하는 것을 선택.

---

### HTTP의 비연결성으로 인한 단점이 뭐가 있을까?

동일한 클라이언트의 모든 요청에 대해, 매번 새로운 연결/해제 과정을 거쳐야 해서 이에 따른 오버헤드 발생.

---

### HTTP의 비연결성을 해결하기 위한 방법?

Keep-Alive라는 기능을 사용할 수 있다.

- Keep-Alive 기능을 사용하면, handshake 과정이 생략되므로 성능 향상을 기대할 수 있다.

> - Keep-Alive 기능은 HTTP 1.0부터 실험적으로 지원되었고, 1.1부터는 default로 지원되었다. 2.0에서는 무시된다.

---

### Keep-Alive를 사용하는 방법?

HTTP 1.0에서는

- Keep-Alive를 사용하기 위해, HTTP 헤더 중 `Connection` 헤더의 값을 'Keep-Alive'로 설정해야 한다.
- `Keep-Alive` 헤더에는 `timeout`과 `max` 값을 설정한다.

  - `timeout`: 연결이 열려있어야 하는 최소한의 시간.
  - `max`: 연결이 닫히기 전에 전송될 수 있는 최대 요청 수.

  (예: `Keep-Alive: timeout=5, max=1000`)

HTTP 1.1에서는 default로 Keep-Alive가 지원된다.

- Keep-Alive를 지원하지 않기 위해서는 `Connection` 헤더의 값을 'Close'로 설정해야 한다.

---

### Keep-Alive의 장점?

성능 개선: 여러 번의 요청과 응답에 대해 커넥션이 최초 1회에만 이뤄지기 때문에 시간이 단축.

---

### Keep-Alive의 단점?

바쁜 서버 환경에서 사용할 경우

- 모든 요청에서 연결을 유지해야 하기 때문에 메모리를 과도하게 많이 사용하게 된다. → 성능 저하.

---

### 무상태성을 해결하기 위한 방법?

- 쿠키
- 세션
- 토큰

> 이러한 connection 관련 context를 TCP/IP packet에 구현하지 않고 브라우저나 어플리케이션 단에서 처리하는(세션, 쿠키 등) 이유는, 어떤 새로운 버전의 TCP, 혹은 관련 프로토콜이 적용되어도 문제 없이 호환되도록 하기 위함이다.

> localStorage나 sessionStorage는?
>
> - 무상태성을 해결하기 위해 사용할 수 있지만, 근본적으로는 클라이언트에 정보를 저장하기 위한 방법이다.
> - 이전에는 클라이언트에 정보를 저장하기 위한 방법이 cookie 밖에 없었지만, Web Storage API(localStorage, sessionStorage)라는 대안이 등장했다.
> - 쿠키는 매 요청마다 헤더에 모든 쿠키가 첨부되어 보내지기 때문에, 성능 상 문제가 있기 때문이다.

---

### HTTP 요청/응답 메시지의 구성(형식)은?

Request(Response) Header + Request(Response) Body로 구성되어 있다.

Header

- 첫 번째 줄  
  요청) 요청 메서드 + 요청 URL + HTTP 프로토콜 버전 (ex: `GET /icon.png HTTP/1.0`)  
  응답) HTTP 프로토콜 버전 + 응답 코드 + 응답 메시지 (ex: `HTTP/1.0 404 Not Found.`)
- 두 번째 줄~ : Header 정보들

Body

- 요청) 요청과 관련된 내용 (POST, PUT, PATCH에만 존재)  
  응답) 실제 응답 리소스 데이터.

> Header와 Body는 빈 줄로 구분된다.

---

### HTTP Method에는 어떤 것들이 있나?

GET, POST, PUT, PATCH, OPTIONS, HEAD 등이 있다.

---

### GET과 POST의 차이?

GET

- 서버로부터 정보를 조회하기 위해 사용되는 메소드
- 데이터를 querystring에 담아 전송한다.
- 멱등하게 설계된 메소드

> - querystring은 URL의 끝에 ?와 함께 `이름=값` 으로 쌍을 이루는 요청 파라미터이다.
> - GET 요청은 캐싱될 수 있다.

POST

- 서버의 리소스를 생성하기 위해 설계되었다.
- 데이터를 body에 담아 전송한다.
- 멱등하지 않게 설계된 메소드

> - POST로 요청을 보낼 때는 헤더 `Content-Type`에 요청 데이터의 타입을 표시해야 한다.
> - `Content-Type`에 데이터 타입을 표시하지 않으면 서버가 내용이나, URL에 표시된 리소스의 확장자명 등을 보고 유추한다.
> - 유추할 수 없는 경우에는, `application/octet-stream`으로 요청을 처리한다.
>
> - `Content-Type` 중 `text/plain`은 텍스트 파일을 위한 기본값이다.
> - `Content-Type` 중 `application/octet-stream`은 다른 모든 경우를 위한 기본값이다.
>
> - RFC에 따르면, body payload가 있는 요청, 즉 POST와 PUT, PATCH에만 `Content-Type`이 설정되면 된다.

---

### 멱등성이란?

연산의 성질 중 하나로, 연산을 여러 번 적용하더라도 결과가 달라지지 않는 성질.

---

### GET과 HEAD의 차이?

GET

- 서버로부터 정보를 조회하기 위해 사용되는 메소드

HEAD

- GET 메소드로 요청했을 때의 응답 헤더만 요청하는 메소드
- 웹 서버에 대한 정보 확인, 헬스 체크, 버전 확인 등에 사용되는 메소드

---

### POST와 PUT의 차이?

POST

- 리소스를 생성하기 위한 메소드이다.
- 멱등하지 않다. (매 요청마다 자원을 새로 생성한다.)

PUT

- 리소스를 생성/수정하기 위한 메소드이다.
- 멱등하다.
  (자원 전체를 수정하기 때문이다.
  해당 자원이 없다면, 생성이 될 것이고 있다면 수정이 된다. 여러번 실행되더라도 요청한 값으로 생성/수정한 상태가 유지된다.)

---

### PUT와 PATCH의 차이?

PUT

- 리소스의 생성/수정에 사용된다.
- 리소스 전체를 갱신할 때 사용된다.
- 멱등하다. (자원 전체를 갱신하기 때문이다.)

PATCH

- 리소스의 수정에 사용된다.
- 리소스의 일부를 수정할 때 사용된다.
- 멱등하지 않다! (자원의 전체가 아닌 일부가 갱신되기 때문에 멱등성을 보장할 수 없다.)

---

### OPTIONS 란?

서버에서 지원하는 method의 종류를 확인할 때 사용된다.

> - 응답 메시지의 `Allow` 헤더를 통해 허용되는 메소드를 확인할 수 있다.  
>   `HTTP/1.1 200 OK`  
>   `Allow: OPTIONS, GET, HEAD, POST`

---

### OPTIONS가 언제 사용될까?

CORS의 preflight requests에 사용된다.

---

### CORS의 preflight request의 목적은?

브라우저가 서버에게 요청을 보내도 괜찮은지 확인하기 위한 목적이다.

- 서버가 헤더 `Access-Control-Allow-Origin`을 포함해 응답을 보낸다.
  - 브라우저는 자신이 보낸 요청의 `Origin` 헤더의 값이 `Access-Control-Allow-Origin`에 포함되어 있는지 확인하고, 없다면 CORS 에러를 띄운다.

---

### (참고) 주요 HTTP 응답 코드

1XX: 정보

- 요청의 일부를 받았다, https로 전환을 성공했다 등의 정보를 알려줌.

2XX: 성공

- 200: 성공
- 201: 새로운 자원 생성에 성공
- 204: 성공했지만, 응답할 컨텐츠는 없다.

3XX: 리다이렉션

- 302: 임시적으로 주소가 바뀌었을 때 리디렉션
- 304: 이전에 보냈던 요청과 결과가 다르지 않아서 캐싱된 페이지를 보여줄 경우.

4XX: 클라이언트 오류

- 401: Unauthorized. 인증되지 않은 사용자.
- 403: Forbidden. 인가되지 않은 권한.
- 404: Not Found

> HTTP1.1에서는 401과 403이 명확하게 구분되지 않는다. Web API는 항상 401을 내보낸다.

5XX: 서버 오류

---

### 인증과 인가의 차이점은?

인증: 클라이언트가 자신이 주장하는 사용자와 같은 사용자인지 확인하는 과정

인가: 클라이언트가 하고자 하는 작업이 해당 사용자에게 허가된 작업인지 확인하는 과정

---

### HTTP 헤더 중 알고 있는 헤더가 뭐가 있나요?

---

### HTTP의 보안 취약점은?

요청과 응답 메시지가 평문으로 오고 가기 때문에, 중간에서 탈취가 가능하다.

## HTTPS

### HTTPS란?

- 보안이 강화된 HTTP
- 클라이언트와 서버가 먼저 암호화 통신 채널을 수립한 다음 메시지를 전송함으로써 보안을 강화한다.

---

### HTTPS를 통해 얻을 수 있는 이점은?

1. 기밀성: 두 참여자 간 통신의 내용을 보호한다.
2. 인증: 통신하는 웹 사이트의 진위 여부를 확인할 수 있다.

---

### HTTPS가 암호화 채널을 수립할 때 사용하는 암호화 프로토콜은?

SSL 또는 TLS

> - SSL과 TLS의 차이는?  
>   : SSL은 넷스케이프가 개발한 프로토콜, TLS는 공인된 표준. SSL 3.0부터 TLS 1.0으로 대체되었으나, SSL과 TLS가 혼용되고 있다.

---

### SSL 인증서란?

클라이언트와 서버 간 통신을 제3자가 보증해주는 전자 문서.

---

### SSL 인증서의 역할은?

- 클라이언트가 접속하는 서버가 신뢰할 수 있는(클라이언트가 의도한) 서버임을 보장한다.
- SSL 통신에 사용할 공개키를 (서버가 SSL 인증서를 통해) 클라이언트에게 제공한다.

---

### SSL 인증서에 포함된 정보는?

- 서비스에 대한 정보(ex: 인증서를 발급한 CA, 서비스의 도메인 등)
- 서버 측 공개키(공개키의 내용, 공개키의 암호화 방법)

> - SSL 인증서는 위 정보가 포함된 채로, CA에 의해 CA의 비공개키로 암호화된다.
> - 이는 추후 클라이언트가 CA의 공개키로 복호화되어 서버의 신원을 파악할 수 있는 계기를 제공함.
>
> - CA(Certificate Authority): 클라이언트가 접속한 서버가 신뢰할 수 있는 서버가 맞음을 보장하는 역할을 하는 민간 기업.
> - 브라우저는 내부적으로 공인된 CA의 리스트를 미리 파악하고 있다.

---

### SSL 인증서가 서비스를 보증하는 과정은?

- 브라우저가 서버에 접속하면, 서버는 가장 먼저 인증서를 제공한다.
- 인증서를 받은 브라우저는 해당 인증서를 발급한 CA가 자신이 내부적으로 가지고 있는 공인 CA의 리스트에 존재하는지 확인한다.
- 해당 CA의 공개키로 인증서를 복호화한다.
  복호화할 수 있다는 것은, 인증서가 해당 CA의 비공개키로 암호화 되었음을 의미한다. 그리고 이는 브라우저가 접속한 서버가, CA에 의해 검토되었다는 것을 의미한다.

---

### SSL 통신 과정을 설명해본다면?

크게 3가지 단계를 거친다.  
`handshake → session → session 종료`

1. handshake

   (1) Client Hello: 클라이언트가 서버에 접속한다. 이 과정에서 다음 정보들을 전달한다.

   - 클라이언트가 지원하는 암호화 방식 리스트  
     : 클라이언트와 서버가 함께 사용할 암호화 방식을 협상하기 위함.
   - 클라이언트 측에서 생성한 랜덤 데이터  
     : 추후 pre-master key를 생성할 때 사용된다.
   - 세션 아이디  
     : 이미 SSL handshake를 진행했을 경우 기존 세션을 재활용하기 위함.

   (2) Server Hello: 서버가 다음 정보들을 전달한다.

   - SSL 인증서
   - 클라이언트가 지원하는 암호화 방식 리스트 중 서버가 선택한 방식
   - 서버 측에서 생성한 랜덤 데이터  
     (추후 pre-master key를 생성할 때 사용된다.)

   (3) 클라이언트는 SSL 인증서를 통해 서버의 신원을 확인한다.  
   ("SSL 인증서가 서비스를 보증하는 과정은?" 참고)

   (4) 클라이언트는 자신이 생성한 랜덤 데이터와 서버가 생성한 랜덤 데이터를 조합해 pre master key를 생성한다.

   - pre master key는 추후 대칭키를 생성할 때 사용되므로 외부에 공개되어서는 안된다.
   - SSL 인증서 내부에 있는 서버의 공개키로 pre master key를 암호화해 서버로 전송한다.

   (5) 클라이언트와 서버는 일련의 과정을 거쳐 pre master key를 master key로 만든다.

   - master key는 session key를 만드는 데 사용되며, session key는 데이터를 주고 받을 때 사용할 대칭키가 된다.

   (6) 클라이언트와 서버는 handshake 과정이 끝났음을 서로에게 알린다.

2. session: 데이터를 주고 받는다.

3. session 종료: 데이터를 모두 주고 받으면, SSL 통신이 끝났음을 서로에게 알리고 종료한다.

## HTTP/2

### HTTP/2 이전 버전들의 성능 제한 이슈는? (HTTP/2가 등장한 이유는?)

HTTP/2 이전 버전들은 의도적으로 단순 구현을 위해 고안되었고, 단순 구현을 위해 성능을 희생했다.

- 클라이언트는 지연 시간을 줄이기 위해 여러 개의 연결을 사용해야 한다.

  > - HTTP/1.x에서 응답은 동기적으로, 순서를 지키며 수행된다. (서버는 요청 받은 순서대로 응답하며, 이전의 응답이 끝나야 다음 응답을 시작한다.)
  > - 때문에 하나의 응답이 지연될 경우 뒤의 응답도 지연되게 되는데, 이러한 현상을 head-of-line(HOL, HOL Blocking)이라고 한다.
  > - 이러한 성능 제한을 해결하기 위해 HTTP/1.x에서는 병렬 요청을 위해 여러 개의 TCP 연결을 사용한다. 하지만, 이러한 대응에도 불구하고 결국 하나의 TCP 연결 당 하나의 응답이 오기 때문에 근본적인 해결책이 되지 못한다.

- 요청, 응답 헤더를 압축하지 않아 불필요한 네트워크 트래픽이 발생한다.

---

### HTTP/2의 목적은?

HTTP/2 이전 버전의 성능 제한을 해결함으로써 웹 페이지 로드 시간을 줄이기 위한 목적.

---

### HTTP/2가 제공하는 주요 기능에는 어떤 것들이 있나?

- 요청과 응답 다중화
- 요청 자원(스트림)에 우선순위 지정
- 서버 푸시 지원
- 헤더 압축

---

### HTTP/2는 HTTP의 의미 체계를 대체(변경)하는지?

HTTP/2는 HTTP의 의미 체계를 (어떤 식으로든, 전혀) 수정하지 않는다. (HTTP 메서드, 헤더, 상태 코드 등이 그대로 유지된다.)

HTTP/2가 수정하는 것은,

- 클라이언트와 서버 간 데이터 프레임이 구성되는 방식과
- 데이터가 전송되는 방식이다.

> - 즉, HTTP/2는 HTTP 버전의 대체가 아닌 확장이다.

---

### HTTP/2의 바이너리 프레이밍 계층이란?

> - 바이너리 프레이밍 계층은 HTTP/2 성능 향상의 핵심이다.

- HTTP/2에서 HTTP의 의미 체계(메소드, 헤더, body, 상태 코드 등)를 인코딩하는 메커니즘.

  > - 바이너리 프레이밍 계층은 HTTP의 의미 체계를 바꾸는 것이 아니다. (인코딩 방식일 뿐이다.)
  > - 클라이언트와 서버는 서로를 이해하기 위해 새로운 바이너리 인코딩 메커니즘을 사용해야 한다.
  >
  > - 바이너리 프레이밍 계층은 Application layer와 TCP/IP layer 중간에 위치하는 layer다.

- 헤더와 body가 '메시지(message)'와 '프레임(frame)'으로 분할된다.

  > - HTTP/1.x은 요청/응답 메시지가 텍스트로 구성되어 있으며, 줄바꿈으로 헤더와 body가 구분된다.

- 각각의 메시지와 프레임은 바이너리 형식으로 인코딩된다.

---

### HTTP/2의 스트림, 메시지, 프레임에 대해 설명?

![Web%20a8bd6cb86f15403fa6e62833f6c3d9f2/Untitled%202.png](Web%20a8bd6cb86f15403fa6e62833f6c3d9f2/Untitled%202.png)

스트림(stream)

- 구성된 연결 내에서 전달되는 바이트의 양방향 흐름

> - 스트림은 하나 이상의 메시지로 구성된다.
> - 단일 TCP 연결 내 전달될 수 있는 스트림의 수는 제한이 없다.

메시지(message)

- 논리적 요청, 응답 메시지에 매핑되는 단위.
- 하나 이상의 프레임으로 구성.

프레임(frame)

- HTTP/2에서 통신의 최소 단위.

> - 각 프레임에는 하나의 프레임 헤더가 포함된다.
> - 프레임 헤더는 프레임이 속한 스트림을 식별한다.
> - 특정 유형의 데이터(ex: 헤더, body)를 전달한다.

---

### HTTP/2가 요청, 응답 다중화를 지원하는 원리는?

클라이언트와 서버는 HTTP 메시지를 프레임으로 분할하고, 그 프레임을 인터리빙(interleaving, 중간중간에 끼우다)해 전송한다.

> - 인터리빙된 프레임은, 전달 받은 측에서 프레임 헤더의 스트림 식별자를 통해 원래대로 조립할 수 있다.

---

### HTTP/2의 요청, 응답 다중화를 통해 얻을 수 있는 이점은?

- 단일 연결을 통해 head-of-line 없이 병렬로 데이터를 주고 받을 수 있다.
- 이미지 스프라이트, 도메인 샤딩 등의 불필요한 임시 방편을 제거할 수 있다.

> - 도메인 샤딩(domain sharding): 같은 서버의 여러 도메인으로 컨텐츠를 분할해 병렬로 응답을 처리하는 기법. (결국 하나의 tcP 연결은 하나의 응답 밖에 하지 못하고, 도메인 당 connection 수의 제한이 존재해 근본적인 해결책이 되지 못한다.) (HTTP/1.x은 각 출처마다 6개의 TCP 연결만 허용한다.)

---

### HTTP/2의 (출처당) 단일 연결을 통해 얻을 수 있는 이점은?

- 더 적은 연결 → 메모리 처리량, 서버 리소스, 네트워크 지연 시간, 운영 비용 감소
- 동일한 연결 재사용 → 더 적은 TLS handshake, 더 많은 세션 재활용

---

### HTTP/2에서 스트림 우선순위를 지정하는 과정은?

HTTP/2는 각 스트림이 가중치와 종속성을 갖도록 허용한다.

- 각 스트림에는 1~256의 가중치가 할당될 수 있다.
- 각 스트림에는 다른 스트림에 대한 종속성이 부여될 수 있다.

클라이언트는 가중치와 종속성을 사용해 우선순위 지정 트리를 구성한다.

서버는 우선순위가 높은 응답이 최적으로 전달되도록 처리한다.

> - 종속성은(종속성 선언은), 특정 리소스가 종속되어 있는 상위 요소의 리소스를 가능하면 먼저 처리하고 특정 리소스를 처리하라는 의미이다.
> - 종속성과 가중치는 처리나 전송 속도를 보장(강제)하지 않는다. 이는 바람직한 동작으로, 우선순위가 높은 리소스가 차단될 경우 우선순위가 낮은 리소스가 함께 차단되는 것을 방지한다.

---

### HTTP/2의 서버 푸시에 대해 설명?

HTTP/1.x에서는

- 클라이언트가 서버로부터 문서를 제공받고, 해당 문서를 확인해서 추가로 필요한 리소스를 요청한다.  
  (HTML의 인라인 script, css, img 등)

HTTP/2에서는 응답을 다중화할 수 있으므로, 클라이언트가 요청하기 전에 미리 필요한 리소스를 알아서 응답한다.

---

### HTTP/2의 헤더 압축에 대해 설명?

HTTP/1.x에서는

- 헤더가 항상 일반 텍스트로 전송된다.

HTTP/2에서는 HPACK이라는 압축 형식을 사용해 요청, 응답 메시지의 헤더를 압축한다.

HPACK 압축 방식은

- 헤더 필드를 Huffman encoding으로 인코딩한다. → 헤더 필드의 크기를 줄인다.
- 이전에 전송된 헤더 필드의 색인 목록(header table)을 클라이언트와 서버가 업데이트하고 유지하도록 한다.  
  (이미 전송된, 중복된 header 값은 인덱스만 전송, 서버 측에서 header table로 복구)

## 쿠키 & 세션

### 쿠키란?

브라우저 로컬에 저장되는 데이터 파일.

> - 브라우저마다 쿠키는 다르게 저장/사용된다.
> - 쿠키는 1개 당 최대 4KB의 데이터를 저장할 수 있다.

---

### 쿠키는 어떻게 구성되어 있나?

- Name: 쿠키의 이름
- Value: 쿠키에 저장된 값
- Expires: 쿠키가 언제 삭제되는지 결정.
- Domain: 쿠키가 사용되는 도메인을 지정.

  > 쿠키 Domain과 현재 탐색 중인 서비스가 일치하지 않으면 타사 쿠키로 간주하고 브라우저에서 거부한다.

- Path: Cookie 헤더를 전송하기 위해 URL 내에 반드시 포함되어야 하는 URL 경로.
- Secure: 설정 시 HTTPS 상에서 암호화된 통신인 경우에만 쿠키가 전송됨.

  > Secure일지라도, 민감한 정보는 쿠키 내에 저장하면 안된다. Secure 플래그가 본질적으로 보안적 조치를 취해주는 것은 아니다.

- HttpOnly: 설정 시 JavaScript로 쿠키에 접근할 수 없다. (`document.cookie`)

  > - HttpOnly 옵션은 XSS 공격을 방지하는 데 사용될 수 있다.

---

### 쿠키를 생성하는 방법은?

서버가 클라이언트로부터 응답할 때, `Set-Cookie` 헤더를 사용하면 된다.

- 해당 헤더는 클라이언트로 하여금 쿠키를 저장하라고 명령한다.

```
예시)
HTTP/1.0 200 OK
Content-type: text/html
Set-Cookie: yummy_cookie=choco
Set-Cookie: tasty_cookie=strawberry; Expires=...; Secure; HttpOnly;
```

---

### 쿠키를 요청 메시지에 어떻게 설정하나?

클라이언트가 서버로부터 Set-Cookie 헤더가 포함된 응답을 받으면,

- 이후 서버로 전송되는 모든 요청에 저장한 모든 쿠키를 첨부해서 보낸다.

---

### 요청 메시지에 쿠키가 어디에 들어가있나?

Cookie라는 헤더에 존재한다.

```
GET /sample_page.html HTTP/1.1
Host: www.example.org
Cookie: yummy_cookie=choco; tasty_cookie=strawberry
```

---

### 쿠키의 단점은?

- 성능 상 단점: 매 요청에 브라우저가 저장하고 있는 모든 쿠키를 첨부해서 보내기 때문에, 쿠키의 데이터 양이 많으면 성능 상 무리가 갈 수 있다.
- 보안상 취약점이 존재.

---

### 쿠키의 성능 상 단점을 보완하기 위한 대안은?

localStorage나 sessionStorage 같은 Web Storage API를 사용하면 된다.

- 이들은 매 요청 시마다 함께 첨부되어 전송되지 않는다.

---

### 쿠키의 보안적 취약점?

- XSS를 사용해 사용자의 인증 세션 등에 사용되는 쿠키가 탈취될 수 있다.  
  (document.cookie로 쿠키를 탈취하는 script 등)

---

### 쿠키의 보안적 취약점에 대한 대안은?

쿠키에 HttpOnly 속성으로 자바스크립트를 통해 쿠키에 접근할 수 없게 만든다.

---

### 쿠키가 만료되는 시점은?

(Set-Cookie로) 쿠키를 생성할 때 expires 옵션에 명시한 만료기간까지 유효하다.

> 쿠키는 브라우저가 종료되어도 소멸되지 않는다.

---

### 세션이란?

데이터를 HTTP session id로 식별해 서버 DB에 저장하는 방법.

---

### 세션을 생성하는 절차는?

1. 클라이언트가 서버에 자원을 요청한다.

2. 서버에서는 요청의 쿠키에서 session id를 확인한다.

- 있다면, 해당 세션을 찾아 적절한 응답을 한다.
- 없다면, 서버는 새로운 세션과 session id를 생성한 후, Set-Cookie 헤더를 통해 클라이언트에게 쿠키에 session id를 생성할 것을 명령한다.

3. 클라이언트는 이후 쿠키에 session id을 포함해 요청을 보낸다.

---

### 세션의 데이터가 유지되는 기간은? (만료되는 시점은?)

브라우저가 종료되는 시점에 세션도 폐기된다.

---

### 쿠키와 세션의 차이점?

- 저장 위치
  - 쿠키는 로컬에,
  - 세션은 서버에 데이터를 저장한다.
- 보안
  - 쿠키는 탈취와 변조가 가능하지만,
  - 세션은 서버에 존재하기 때문에 상대적으로 안전하다.
- 만료 시기
  - 쿠키는 브라우저를 종료해도 파일로 남아있지만,
  - 세션은 브라우저 종료 시 세션을 삭제한다.
- 속도
  - 쿠키는 파일로부터 읽어오기 때문에 상대적으로 빠르지만,
  - 세션은 요청마다 서버에서 처리가 필요하기 때문에 느리다.

---

### 세션의 장점에도 불구하고 쿠키를 사용하는 이유?

세션은 서버 자원을 활용하기 때문에, 사용자가 많을 경우 자원 소모가 커 성능에 영향을 미칠 수 있기 때문이다.

## localStorage & sessionStorage

### localStorage(또는 sessionStorage)란?

웹 스토리지 객체로,
브라우저 내에 키-값 쌍을 저장할 수 있다.

---

### 쿠키 대신 사용하는 이유는?

- 서버로 네트워크 요청 시 데이터가 함께 전송되지 않는다.  
  → 더 많은 데이터를 저장할 수 있다.
- 서버가 HTTP 헤더를 통해 조작할 수 없다. 클라이언트의 자바스크립트 내에서만 수행될 수 있다.

---

### localStorage과 sessionStorage의 차이점은?

localStorage

- origin(출처)이 같은 경우, 데이터가 모든 탭과 창에서 공유된다.
- 브라우저나 OS가 재시작해도 데이터가 파기되지 않는다.

sessionStorage

- 현재 떠있는 탭 내에서만 유지된다.
- 페이지 새로고침에는 유지되지만, 탭을 닫았다가 새로 열 때에는 사라진다.

## CORS

### CORS란?

웹 상의 리소스를 다른 출처로부터 요청할 수 있게 허용하는 방법.

> - "Cross Origin Resource Sharing"
> - 즉, 웹 브라우저에서 실행되는 JavaScript에서 직접적인 HTTP 통신을 통해 외부 출처에서 데이터를 받아오는 것이 불가능하다. 하지만 HTML의 `<script>` 요소는 외부 출처로부터 조회된 내용을 실행하는 것이 허용된다..(→ JSONP와 관련)

---

### origin(출처)이란?

프로토콜(`https://`) + 호스트(`www.google.com`) + 포트 번호(`:443`)

> - 단, 포트 번호는 http, https에 대한 기본 포트가 RFC에 정의되어 있기 때문에, 생략 가능하다. (별도로 명시한 포트를 사용하지 않는 이상)
> - 호스트: 자원을 가지고 있는 주체를 식별하는 이름

---

### 같은 출처, 다른 출처를 판단하는 기준은?

전체 URL 중 프로토콜, 호스트, 포트가 동일한지, 아닌지의 기준을 따른다.

---

### SOP(동일 출처 정책)란?

동일 출처에서만 리소스를 공유할 수 있다는 정책.

> - "Same Origin Policy"
> - SOP는 몇 가지 조항을 두고 해당 조항을 만족하는 리소스 요청에 대해서는 허용하기로 했다. 그 중 하나가 CORS이다.

---

### SOP가 존재하는 이유는?

출처가 다른 두 개의 어플리케이션이 마음대로 소통하는 환경은 보안적으로 위험할 수 있다.

- XSS, CSRF 등의 공격에 취약해질 수 있다.

---

### SOP가 교차 출처로 삽입하는 리소스를 허용하는 경우는?

- `<script src="..."></script>` 태그로 추가하는 JavaScript

  > - 스크립트에서 시작하는 교차 출처 HTTP 요청은 SOP에 의해 제한된다.  
  >   대표적으로 XMLHttpRequest와 Fetch API가 있다.

- `<link rel="stylesheet" href="...">`로 적용하는 CSS

  > `<link>` 요소는 현재 문서와 외부 리소스의 관계를 명시한다.
  >
  > - `rel`은 관계(relationship)를 의미하며, 현재 문서와 연결된 외부 리소스와의 관계가 어떻게 되는지 설명한다.
  > - `href`는 외부 리소스의 경로를 나타낸다.

- `<img>`로 표시하는 이미지
- `<video>`나 `<audio>`로 표시하는 미디어

---

### 브라우저와 서버 중 CORS를 판단하는 주체는?

브라우저.

> - 그래서, CORS를 위반하는 요청이더라도 서버는 정상 응답을 해준다.
> - 브라우저는, 서버에서 정상 응답을 받아도 CORS를 위반한 요청/응답이라면 CORS 에러를 발생시킨다.

---

### CORS가 동작하는 방식은? (브라우저가 CORS를 판단하는 방법은?)

- 브라우저(or, 클라이언트 어플리케이션)는 요청을 보낼 때 HTTP 헤더의 `Origin` 필드를 통해 요청을 보내는 출처를 담아 보낸다.
- 서버는 응답 시 HTTP 헤더의 `Access-Control-Allow-Origin` 필드에 "해당 리소스를 접근하는 것이 허용된 출처"를 담아 보낸다.
- 브라우저는 자신이 보낸 요청의 `Origin`과 서버 응답의 `Access-Control-Allow-Origin`을 비교한 후, 일치하지 않는다면 CORS 에러를 낸다.

---

### CORS가 동작하는 세 가지 시나리오에 대해 알고 있는지?

- Simple Request
- Preflight Request
- Credentialed Request

---

### Simple Request란? (+ 과정을 설명해본다면?)

preflight(예비 요청) 없이 서버에 요청을 보내는 시나리오.

- preflight 없이 서버에 요청을 보낸 후,
- 서버 응답의 Access-Control-Allow-Origin과 요청의 Origin을 비교해 CORS를 판단한다.

---

### Simple Request를 사용할 수 있는 조건은?

1. 요청의 메소드는 GET, HEAD, POST 중 하나여야 한다.

2. 특정 헤더를 제외한 다른 헤더를 사용해서는 안된다.  
   (허용 헤더 예: `Content-Type` 등)

   > - `Content-Type`: 컨텐츠의 유형이 무엇인지 나타낸다.

3. `Content-Type`을 사용하는 경우, 그 중 3가지 옵션만 허용된다.  
   (허용 옵션: `application/x-www-form-urlencoded`, `multipart/form-data`, `text/plain`)

---

### Preflight Request란? (+ 과정을 설명해본다면?)

클라이언트가 서버에게 본 요청을 한 번에 보내기 전, 먼저 preflight(예비 요청)를 보내는 시나리오.

> - Preflight 시나리오는 웹 애플리케이션 상 가장 많은 시나리오이다.

- 클라이언트는 `OPTIONS` 메소드로 preflight 요청을 보낸다.
  (물론 이 때 `Origin` 필드가 포함된 HTTP 헤더가 첨부된 요청이 전송된다.)

  > - 이 때, 자신이 예비 요청 이후 보낼 본 요청에 대한 정보들도 포함하고 있다.  
  >   (ex: `Accept-Language` 등)

- 서버는 `Access-Control-Allow-Origin` 필드를 포함한 헤더와 함께 응답을 보낸다.
  (이외에도 `Allow` 필드를 통해 요청 가능한 HTTP 메소드를 알려주는 등 여러 정보를 포함해 응답한다.)
- 클라이언트는 `Access-Control-Allow-Origin`과 `Origin`을 비교해 CORS를 판단하고, 문제가 없다면 본 요청을 보낸다.

---

### Credentialed Request란?

다른 출처 간 리소스 통신에서 인증된 요청을 사용하는 시나리오.

> - 기본적으로 비동기 요청 API인 `XMLHttpRequest` 객체나 `fetch` API는 별도의 옵션 없이 헤더에 인증과 관련된 정보를 함부로 담지 않는다.

---

### Credentialed Request를 사용하는 방법은?

HTTP 헤더의 `credentials` 필드에 옵션 값을 설정한다.

사용 가능한 옵션 값으로는,

- `same-origin`(default): 같은 출처 간 요청에만 인증 정보를 담을 수 있다.
  (같은 출처 간 요청에만 헤더에 인증 정보를 포함시킨다.)
- `include`: 모든 요청에 인증 정보를 담을 수 있다.
- `omit`: 모든 요청에 인증 정보를 담지 않는다.

> - credentials의 `same-origin`이나 `include` 옵션으로 요청에 인증 정보를 포함하게 된다면, 브라우저는 (단순히 `Access-Control-Allow-Origin` 헤더를 검사하는 것 이상으로) CORS 정책 위반 여부를 판단할 때 몇 가지 조건을 추가하게 된다.
> - `credentials: same-origin`인 상태에서 다른 출처 간 요청 → 인증 정보 담기지 않는다.  
>   `credentials: same-origin`인 상태에서 같은 출처 간 요청 → 인증 정보 담긴다.  
>   `credentials: include`인 상태에서 모든 요청 → 인증 정보 담긴다.

---

### credentials에 옵션이 same-origin(그리고 같은 출처 간 통신일 때)이거나 include일 때 브라우저가 추가로 확인하는 조건은?

1. 응답 헤더의 `Access-Control-Allow-Credentials` 값이 `true`여야 한다.

2. 응답 헤더의 `Access-Control-Allow-Origin` 값이 `*`(asterisk, wildcard)이면 안된다. (명시적인 URL이어야 한다.)

---

### CORS를 해결할 수 있는 방법은?

1. 서버 응답에 `Access-Control-Allow-Origin` 세팅하기

2. 프록시 서버 사용하기

3. JSONP

---

### 프록시 서버를 활용해 CORS 에러를 해결하는 과정은?

프록시 서버에서 응답 헤더의 `Access-Control-Allow-Origin` 값을 요청 헤더의 `Origin` 값으로 설정

---

### CORS(혹은 Access-Control-Allow-Origin)의 단점?

`Access-Control-Allow-Origin`에는 단 하나의 문자열만 넣을 수 있다는 점.  
(즉, `*`, `null`, 아니면 단일 도메인)

**해결 방법?**

- 서버 측에서 허용 가능한 Origin 목록을 배열 등으로 보관.
- 요청이 왔을 때, 해당 요청의 Origin이 해당 배열에 존재할 경우, `Access-Control-Allow-Header`에 해당 Origin을 설정한 후 응답.

```jsx
/* 예시 */
const responseHeader = (req, res) => {
  const allowedOrigins = ["http://example_1.com", "http://example_2.com"];
  const { origin } = req.headers.origin;

  if (allowedOrigins.includes(origin)) {
    res.setHeader("Access-Control-Allow-Origin", origin);
  }
};
```

---

### JSONP란?

HTML의 `<script>` 요소를 활용해 SOP 정책을 우회하는 방법.

> - "JSON with Padding"
> - CORS가 등장하기 전까지 사용되었다. 보안 상의 이유로 사라짐.

---

### JSONP를 활용하는(동작하는) 과정에 대해 설명?

1. HTML의 `<script>` 요소로 자원을 요청한다.

- `<script>`의 `src` attribute에 자원을 요청할 외부 출처의 URL을 넣는다.
- 이 때, URL의 query string에 미리 정의한 callback 함수명을 전달한다.

```html
<script
  type="application/javascript"
  src="http://server.example.com/users/3?callback=parseResponse"
></script>
```

2. 서버는 응답을 보낼 때, 전달 받은 콜백 함수에 JSON 데이터를 패딩하여 응답한다.

```json
parseResponse({ "id": 3, "name": "JiHyun", "vegetable": false });
```

3. 웹 브라우저는 전달 받은 데이터를, 유효한 JavaScript 코드로 받아들이고 실행한다.  
   미리 정의한 콜백 함수가 실행되어 전달 받은 데이터를 처리한다.

> - 콜백 함수로 패딩하지 않으면, 웹 브라우저의 JavaScript 엔진이 JSON의 중괄호를 block으로 해석한다. 별도의 변수 정의가 없기에 문법 오류가 발생한다.
> - `<script>`의 `type: "application/javascript"`은 컨텐츠로 실행 가능한 JavaScript 코드를 포함하고 있음을 나타낸다.

---

### JSONP가 더 이상 사용되지 않는 이유는?

- 웹 서비스 구현이 복잡해진다.
- GET 메소드만 지원한다.

## REST

### REST란?

- 자원에 대한 표현으로 해당 자원의 상태를 전달하는 것.
- URI를 통해 자원을 명시하고, HTTP Method로 해당 자원에 대해 CRUD 조작을 하도록 설계된 소프트웨어 아키텍처.

> - "Representational State Transfer"
> - 분산 하이퍼미디어 시스템(ex: World Wide Web)을 위한 소프트웨어 아키텍처의 한 형식이다.

---

### REST의 특징은?

1. 클라이언트-서버 모델을 따른다.

- 클라이언트가 요청을 생성하기 위해 연결을 연 다음, 서버로부터 응답을 받을 때까지 기다린다.

2 무상태성(stateless)를 띈다.

- 서버가 두 요청 간 어떠한 상태나 데이터도 유지하지 않는다.

3. Cacheable(캐시 처리 가능)

- 웹 표준 HTTP를 그대로 사용하기에, 웹에서 사용하는 캐싱 기능(Last-Modified, E-Tag 등)을 그대로 활용할 수 있다.

> - 위 3가지는 REST가 HTTP를 그대로 따르므로 별 다른 설정 없이 함께 활용할 수 있는 이점들이다. 즉, HTTP만 따라도 위 3가지는 자연히 따르게 된다.

4. Uniform Interface

- 자원에 대한 조작을 통일되고 한정된 인터페이스로 수행하는 아키텍처 스타일.

---

### Uniform Interface란? (더 자세히 설명?)

- Identification of resources: 리소스(의 위치)가 URI로 식별되어야 한다.
- Manipulation of resources through representations: 표현을 담아 리소스를 조작해야 한다.
- Self-descriptive messages

  - 메시지는 스스로를 설명할 수 있어야 한다.

    > ex
    >
    > - 이 메시지는 어디를 향하는지 설명
    > - JSON에서 각각의 key가 무엇을 의미하는지 설명(단순히 key의 이름 이상으로)
    > - 메시지 자체에 설명을 담을 수 없다면 '이에 대한 자세한 설명은 어디를 참조해라'라고 명시

- HATEOAS(Hypermedia As The Engine Of Application State)
  - 애플리케이션의 상태는 hyperlink를 통해 전이될 수 있어야 한다.  
    (모든 상태가 hyperlink를 통해 전이될 수 있어야 한다.)

---

### Uniform Interface가 필요한 이유는 뭘까?

클라이언트와 서버가 독립적으로 진화할 수 있도록 하기 위함.  
(이를테면, Uniform Interface를 따르면 서버의 기능이 변경되어도 클라이언트가 이에 맞춰 변경될 필요가 없다. 메시지는 self-descriptive로 언제나 해석이 가능하기 때문이다.)

> - Uniform Interface를 포함해 REST의 명시 규약을 꼭 모두 따라야만 할까?  
>   : 아니다. 시스템 전체를 통제할 수 있다고 생각하거나, 진화에 관심이 없다면 REST를 따르느라 시간을 낭비할 필요가 없다. (라고 로이 필딩이 말했다.)

---

### REST의 구성은?

1. 자원(resource)

- 서버의 자원은 고유한 id를 가지고 있다.
- 클라이언트는 URI로 자원을 구분한다.

2. 행위(verb)

- 클라이언트는 자원을 조작하기 위해 HTTP Method를 사용한다.

3. 표현(representations)

- 서버가 응답으로 보내주는 자원의 상태.
- JSON, XML, TEXT 등 여러 형태의 representation이 있다.

---

### REST에서 정의하는 CRUD Operation과 그에 해당하는 HTTP Method는?

- Create(자원의 생성) → POST
- Read(자원의 조회) → GET
- Update(자원 업데이트) → PUT
- Delete(자원 삭제) → DELETE

---

### REST의 장단점?

장점

- 사용이 쉽다 : HTTP 인프라를 그대로 사용하므로 별도의 인프라를 구축할 필요가 없다.
- API 메시지만으로 의도하는 바를 쉽게 파악할 수 있다.

단점

- 명확한 표준이 없다. (REST는 설계 가이드일 뿐이다.)
- 사용할 수 있는 메소드의 종류가 4가지(GET, POST, PUT, DELETE) 밖에 없다.

---

### REST API란?

REST 기반으로 API를 구현한 것.

> - API(Application Programming Interface): 프로그램 간 정보를 교환할 수 있도록 데이터와 기능의 집합을 제공하는 것.
> - RESTful: 일반적으로 REST 아키텍처를 구현하는 웹 서비스를 나타내는 용어.

---

### REST API의 규칙은?

- URI는 자원을 표현해야 한다.
- 자원에 대한 행위는 HTTP Method로 표현한다.

> 기타 규칙
>
> - 슬래시 구분자(`/`)는 계층 관계를 나타내는 데 사용한다.
> - 하이픈(`-`)은 가독성을 위해 사용될 수 있으며, 밑줄(`_`)은 사용하지 않는다.
> - 소문자만 사용한다.
> - 요청하는 메시지의 body 내용(자원/응답)의 포맷을 나타내기 위해 파일 확장자를 URI에 포함시켜서는 안된다. HTTP header의 `Accept`를 사용해야 한다. (ex: `Accept: image/jpg`)

## 보안 공격(XSS/CSRF/SQL Injection)

### XSS란?

웹 애플리케이션의 관리자가 아닌 이가 웹 페이지에 악성 스크립트를 삽입해 의도치 않은 행동을 하게 하는 공격 방법.

> 'Cross Site Scripting'

---

### XSS를 방지하기 위한 방법은?

- 필터링을 통해 데이터에 삽입된 모든 HTML 태그를 막고, 사이트에 필요한 일부 태그만 허용한다.
- 신뢰할 수 있는 라이브러리를 사용한다. (ex: Naver Lucy XSS filter)

---

### CSRF란?

사이트 사용자가 자신의 의도와는 상관 없이 공격자가 의도한 행위를 특정 웹사이트에 요청하게 만드는 공격 방법.

> 'Cross Site Request Forgery'

---

### CSRF를 방지하기 위한 방법은?

HTTP의 Referer 헤더를 활용

- 현재 요청된 페이지의 이전에 방문한 페이지 주소를 포함한다.
- 해당 요청이 신뢰할 만한 페이지로부터 발생한 것인지 파악할 수 있다.

  > referer를 통한 대응은 조작이 가능하다는 단점이 있다.

토큰을 활용

- 로그인한 유저에게는 토큰을 발급해서, 요청 시 해당 토큰을 함께 보내야만 요청을 실행한다.

---

### SQL Injection이란?

악의적인 사용자가 보안상 취약점을 이용해서 임의의 SQL 문을 주입하고 실행되게 하여 데이터베이스가 비정상적인 동작을 하도록 하는 공격

---

### SQL Injection 중 아는 종류가 있는지?

**논리적 에러를 이용한 SQL injection**

```SQL
SELECT * FROM Users WHERE id = `INPUT1` AND password =`INPUT2`

---(SQL injection)
SELECT * FROM Users WHERE id = ` ` OR 1=1 --  `AND password = `INPUT2`
```

- input에 입력값으로, 싱글 쿼터 하나로 조건 하나를 닫아주고, `OR 1=1`을 추가해줌으로써 WHERE절을 모두 참으로 만든다.
- 그리고 작대기 두개를 넣어줌으로써 뒤의 구문을 모두 주석처리한다.
- ⇒ Users 테이블의 모든 정보를 조회할 수 있게 된다.

**Union 명령어를 이용한 SQL injection**

```SQL
SELECT * FROM Board WHERE title LIKE `%INPUT%`OR contents`%INPUT%`

---(SQL injection)
→ SELECT * FROM Board WHERE title LIKE `%` UNION SELECT null, id, password FROM Users -- %` OR contents `%INPUT%`
```

- 조건
  - 두 테이블의 컬럼 수가 같아야 한다(그래서 `null` 등으로 컬럼 수를 맞춰줘야 한다).
  - 두 컬럼의 데이터 타입이 같아야 한다.
- `Union`: 두개의 쿼리문에 대한 결과를 통합해서 하나의 테이블로 보여주는 명령어

---

### SQL injection의 대응 방안은?

1. 사용자의 입력 값에 대한 검증

> - 입력값은 화이트리스트 기반으로 검증해야 한다: SQL injection에 사용되는 기법과 키워드는 굉장히 많아서, 블랙리스트 기반으로 검증하게 되면 수많은 차단 리스트를 등록해야 하고, 하나라도 성공하게 되면 공격에 성공하는 것이기 때문이다.
> - 키워드를 공백으로 치환하는 방법도 위험하다. 예로, 공격자가 SE`SELECT`LECT를 입력하게 되면, SELECT가 공백이 된 이후에도 `SELECT`가 된다.

2. 에러 메시지 노출 금지

- 공격자가 SQL injection을 하기 위해서는 데이터베이스의 정보 - 이를테면 테이블명, 컬럼명 - 등이 필요하다.
- 만일 에러 발생시 따로 처리해주지 않으면, 에러가 발생한 쿼리문과 함께 에러 내용을 반환하게 된다.  
  → 이때 테이블명, 컬럼명, 쿼리문이 노출될 수 있다.
- ⇒ 에러 발생시 에러 메시지 대신 사용자에게 보여줄 페이지, 혹은 메시지 박스를 띄우도록 한다.

## Web Server & WAS

### Static Page와 Dynamic Page의 차이점은?

Static Page

- 항상 동일한 페이지를 반환한다.
- 웹 서버가 URL로 파일 경로를 받아서, 경로와 일치하는 파일 컨텐츠들을 반환한다.

Dynamic Page

- 인자에 맞게 동적으로 컨텐츠를 반환한다.
- 웹 서버에 의해 실행되는 프로그램에 의해서 만들어진 결과물을 반환한다.

---

### 웹 서버란?

- 소프트웨어에서의 웹 서버: 클라이언트로부터 요청을 받아 정적인 컨텐츠를 제공하는 컴퓨터 프로그램
- 하드웨어에서의 웹 서버: 웹 서버 프로그램이 설치되어 있는 컴퓨터

> - 웹 서버에는 Apache Server, NginX 등이 있다.

---

### 웹 서버의 기능은?

핵심: 클라이언트의 요청을 서비스

구체적으로는 상황에 따라 2가지 정도로 나뉜다.

1. WAS를 거치지 않고 정적인 컨텐츠를 제공

2. 클라이언트의 요청을 WAS로 보내고,
   WAS가 처리한 결과(동적인 컨텐츠)를 클라이언트에게 전달

---

### WAS(Web Application Server)란?

동적인 컨텐츠를 제공하기 위해 만들어진 Application Server

> - WAS에는 Apache Tomcat 등이 있다.

---

### WAS의 기능은?

1. JSP나 Servlet 등을 위한 실행 환경 제공

> - JSP나 Servlet은 (간단히) DB 조회 등을 통해 HTML을 동적으로 생성할 수 있는 Server-side 언어/프로그램이다.

2. DB 접속 등을 통해 비즈니스 로직 수행

---

### 웹 서버가 필요한 이유는?

웹 서버가 정적 컨텐츠만 처리하도록 기능을 분배함으로써 어플리케이션 서버의 부담을 줄일 수 있다.

> 클라이언트가 정적 컨텐츠(이미지 파일 등)를 받게 되는 과정을 살펴보면,
>
> - 클라이언트는 HTML 문서를 먼저 받고, 거기서 필요한 정적 컨텐츠를 다시 서버로 요청한다.
> - 서버로부터 응답을 받게 되면 그제서야 정적 컨텐츠를 받게 된다.
>   웹 서버를 통해 정적 컨텐츠에 대한 응답을 처리하면, 요청이 어플리케이션 서버까지 가지 않고 앞단에서 빠르게 처리할 수 있다.

---

### WAS가 필요한 이유는?

만약 동적인 컨텐츠를 웹 서버만으로 응답해야 한다면,
사용자가 원하는 요청에 대한 결과값을 모두 미리 만들어놓고 대응해야 한다.

: 이는 자원이 엄청나게 많이 필요한 일로, 현실적으로 불가능하다.

→ WAS를 활용하면, 요청에 맞게 그때그때 DB 조회를 통해 동적으로 컨텐츠를 생성해 대응할 수 있으므로, 자원을 효율적으로 활용할 수 있다.

---

### WAS로 웹 서버와 애플리케이션 서버 기능을 모두 수행하지 않는 이유는?

서버 부하 감소

- 정적 컨텐츠는 웹 서버에서 응답함으로서 WAS에 대한 부하를 줄일 수 있다.

로드 밸런싱 & 장애 극복

- (웹 서버와 WAS를 분리함으로써) 하나의 웹 서버에 여러 대의 WAS를 연결할 수 있다.  
  → 로드 밸런싱과 장애 극복이 수월해짐
- 트래픽을 여러 WAS에 로드밸런싱하는 기능을 웹 서버가 수행
- 특정 WAS에 장애가 발생했을 경우,
  웹 서버가 해당 WAS에 요청을 전달하지 않도록 조치함으로써
  장애에 더 쉽게 대응할 수 있게 된다.

## CSR / SSR / SPA

### CSR이란?

데이터 없이 HTML과 정적 파일들만 받아오고, 데이터는 정적 파일이 모두 로드된 이후에 요청해서 받아오는 방식.

> SPA과 CSR은 같다? : No  
> SPA은 서버로부터 처음에만 페이지를 받아오고, 이후에는 동적으로 페이지를 구성해서 새로운 페이지를 받아오지 않는 웹 애플리케이션을 말한다.

---

### SSR이란?

최초 렌더링에 데이터와 정적 파일들을 포함하여 받아오는 형식.

---

### SSR의 장점?

- 모든 데이터가 매핑된 서비스 페이지를 브라우저에게 바로 보여줄 수 있다.
- (CSR에 비해 페이지를 구성하는 속도는 늦어지지만) 전체적으로 사용자에게 보여주는 콘텐츠 구성이 완료되는 시점은 더 빠르다.
- SEO를 쉽게 구성할 수 있다.

---

### SSR의 단점?

---

### SPA란?

- 웹 애플리케이션에 필요한 모든 정적 리소스를 최초에 한 번 다운로드하는 방식.
- 새로운 페이지 요청 시, 페이지 갱신에 필요한 데이터만 전달 받아 갱신한다.

---

### 전통적인 웹 방식은 어땠나?

새로운 페이지를 요청할 때마다 정적 리소스를 다운 받고, 전체 페이지를 다시 렌더링하는 방식.

- 새로고침이 발생되어 사용성이 좋지 않다.
- 변경이 필요 없는 부분까지 모두 갱신하므로 비효율적이다.

---

### SPA의 장점?

- 전체적인 트래픽 감소: 필요한 리소스만 다운
- UX 향상: 필요한 부분만 갱신하므로 새로고침 발생하지 않음.

---

### SPA의 단점?

- 초기 구동 속도: 최초에 필요한 모든 리소스를 다운 받으므로.
- SEO 최적화 문제

---

### SPA를 하면 SEO에 문제가 생기는 이유?

---

### SPA의 단점 - 초기 구동 속도를 극복하기 위한 방법?

- 코드 스플리팅
- lazy loading

---

### SPA의 단점 - SEO 최적화 문제를 극복하기 위한 방법?

- react에서 제공하는 SSR 사용

---

### Routing이란?

애플리케이션 내에서 사용자가 화면을 전환하는 네비게이션 기능을 관리하는 기능.

---

### SPA에서 routing이 어려울 수 있는 이유?

AJAX 요청에 의해 서버로부터 데이터를 받아 화면을 구성하는 경우, 브라우저의 URL은 바뀌지 않는다.

- 이는 사용자의 history를 관리할 수 없음을 의미.

history 관리를 위해서는 각 페이지가 브라우저 주소창에 구별할 수 있는 유일한 URL을 소유해야 한다.

## 프론트엔드 개발의 흐름과 철학

### 단방향 바인딩과 양방향 바인딩의 차이는?

양방향 바인딩은

- Model와 View가 서로를 업데이트.

> Model: 애플리케이션이 가지는 데이터.
> Controller: 유저가 인터페이스에 발생시키는 이벤트를 처리하는 로직.
> View: 사용자 인터페이스 요소.

단방향 바인딩은

- 어플리케이션의 상태가 뷰를 업데이트.
- 뷰는 상태가 업데이트 되도록 이벤트를 발생시키며, 직접 수정하지는 않는다.

> - 데이터 바인딩: 뷰(보여지는 부분)과 모델(데이터)의 소스를 일치시키는 기법.

---

### 양방향 데이터 바인딩의 장단점은?

장점

- 코드가 간결(단방향 데이터 바인딩에 비해): 프레임워크 차원에서 뷰가 모델을 변경시키기 때문.

단점

- 상태의 변화를 파악하기 어려움

---

### 단방향 데이터 바인딩의 장단점은?

장점

- 데이터의 흐름이 예측 가능하다.

단점

- 뷰에서의 변화를 모델에 전달하기 위해 추가적인 작업이 필요하다 → 코드 양 증가

---

### (참고) 데이터 상태 관리의 흐름에 대하여

(reference: `TECH CONCERT: FRONT END 2019 - 데이터 상태 관리. 그것을 알려주마`)

**jQuery**

상태 관리

- jQuery 개발은 DOM에 jQuery로 동작을 입히는 것이다.
- 상태는 어디에 저장? 베이스인 DOM(element)에 저장했다.  
  ex) `<li class="tl_default" data-seq="281743" data-title="취향 확실한 반려견의 눕방" data-expsstartvmdt="2019-04-24 05:59" ... >`
- 다른 element에서도 해당 정보에 접근해야 하기 때문에, 이렇게 element가 상태를 들고 있어야 한다.

jQuery 개발의 흔한 흐름

: Element A를 (jQuery로) 선택해 상태를 가져온다.  
 → Element B를 선택해 상태를 가져온다.  
 → 가져온 데이터를 조합한 후, (fetch 등) API를 호출한다.  
 → 응답 값이 내려오면 정제 후, Element C를 선택해 상태를 업데이트한다.

- 이 로직을 타는 중에, Element A의 상태가 바뀌면, 로직 이후 업데이트된 element C의 상태는 올바른 값일까?  
  : 아닐 것이다.  
  이런 일이 비일비재했고, '상태를 업데이트했는데 왜 엉뚱한 값이 들어있지?;;' 같은 경우가 많았다.
- 즉, 현대의 웹은 수많은 비동기 동작을 가지고, 이로 인해 서로 다른 element의 상태 변화를 추적하기 어렵다. 이는 데이터의 상태가 element를 기반으로 저장되어 있기 때문이다.

**Angular(JS)**

핵심

- "기존 방식(DOM 제어방식)은 변경이 필요한 대상 DOM 요소를 먼저 선택하고, 이후 필요한 작업을 수행하는 형태로 진행되게 됩니다. 반면 AngularJS는 출력할 데이터에 초점을 맞추어 작업이 수행되며, 데이터의 값이 변경되면 출력도 자동으로 수행되도록 처리됩니다."

구조

- SERVICE: 로직이나 상태를 관리
- CONTROLLER: 로직이나 상태를 가지고 VIEW를 만든다.
- VIEW: 사용자에게 보여지는 UI

개발 흐름

- 서비스에서 데이터를 가져옴 → 데이터 조합  
  → API 호출 → 응답 → 응답값 정제  
  → Module B의 상태 업데이트

상태관리의 문제점

- jQuery에서 처럼, 만약 B의 상태를 바꾸는 중에 A의 값이 바뀐다면?  
  → 똑같이 망한다. 근데 왜 Angular가 더 좋을까?
- jQuery는 에러를 추적하기 위해 각각의 Element로부터 상태를 가져와 변경시키는 모든 로직에 console.log를 찍어 실행 순서 등을 확인해봐야 한다.  
  반면, Angular는 상태를 바꾸는 대부분의 로직이 서비스에 존재한다. 때문에 서비스의 로직만 확인해보면 된다.

**Redux**

등장 배경

- 상태(데이터)를 언제, 왜, 어떻게 변화했는지 알기가 어려움!

FLUX 아키텍처

- 단방향 아키텍처
- Action → Dispatcher → Store → View (→ Dispatcher)

CQRS

- 간단히 말하자면 읽는 로직과 쓰는 로직을 분리하는 것.
- flux랑 비슷함. flux도 view는 store를 읽기만 하고, 업데이트는 action을 통해서만 하니.

EventSourcing

- 상태를 변경하고 싶으면, 이벤트 시퀀스로 저장한다. (기록을 남긴다.)

![Web%20a8bd6cb86f15403fa6e62833f6c3d9f2/Untitled%203.png](Web%20a8bd6cb86f15403fa6e62833f6c3d9f2/Untitled%203.png)

장점

- 순수 함수 - 순수 컴포넌트 → 테스트 용이
- 상태가 언제, 어떻게 바뀌었는지 추적이 쉽다. 액션의 기록이 다 남고. 리덕스 툴로 시간을 되돌려 특정 시점을 볼 수 있고..

단점

- 과도한 보일러 플레이트.  
  "1+1을 2로 만들고 싶을 뿐인데 필요한 코드가 너무 많아.. 나라면 간단한 프로젝트에서는 안쓰겠다." 하지만 그게 상태가 복잡한 애플리케이션에서는 도움이 된다.

## Ajax

### Ajax란?

자바스크립트를 이용해서 브라우저와 서버가 비동기적으로 데이터를 교환할 수 있는 방식.

> - Ajax: Asynchronous JavaScript and XML

---

### Ajax의 이점? 사용 이유?

Ajax를 이용하면, 페이지 전체를 요청해 로드하고 렌더링할 필요가 없고, 갱신이 필요한 일부만 로드해 갱신할 수 있다.

> → 빠른 퍼포먼스와 부드러운 화면 표시 효과를 기대할 수 있다.

---

### Ajax를 사용하는 방법은? Ajax가 동작하는 원리는?

브라우저는 XMLHttpRequest 객체를 이용해 Ajax 요청을 생성, 전송한다.

> - 서버가 브라우저의 요청에 대해 응답을 반환하면, 같은 XMLHttpRequest 객체가 그 결과를 처리한다.

```jsx
/* 예시 */
// XMLHttpRequest 객체를 생성한다.
const xhr = new XMLHttpRequest();
// 비동기 방식으로 Request를 오픈한다.
xhr.open("GET", "/users");
// Request를 전송한다.
xhr.send();
```

## JSON

### JSON이란?

클라이언트와 서버 간 데이터 교환을 위한 데이터 포맷

> - JSON: JavaScript Object Notation
> - 자바스크립트의 객체 리터럴과 흡사하지만, JSON은 순수한 텍스트로 구성되어 있다.  
>   규칙이 있는 데이터 구조일 뿐이다.

---

### 다른 데이터 포맷과 비교하여 JSON의 이점?

- 일반 텍스트 포맷보다 효과적으로 데이터 구조화가 가능하다.
- XML에 비해 가볍고, 사용하기 간편하고, 가독성이 좋다.

> XML
>
> - 다목적 마크업 언어
> - 다른 종류의 시스템 간 데이터를 주고 받을 수 있게 설계된 데이터 포맷

---

### JavaScript 객체를 JSON으로 변환하는 방법은? 그 반대는?

- `JSON.stringify`: JS 객체를 JSON 형식의 문자열로 변환한다.

- `JSON.parse`: JSON 데이터를 가지는 문자열을 객체로 변환한다.

## 기타

### URI와 URL의 차이는?

URI(Uniform Resource Identifier)

- 요청하는 자원의 식별자
- 자원을 고유하게 식별하거나 + 위치를 지정할 수 있다.

URL(Uniform Resource Locator)

- URI의 하위 개념으로, 요청하는 자원을 식별할 수 있는 구체적인 위치

> 예시)
>
> - URI이면서 URL인 경우: https://mypage.com/main.html
> - URI이면서 URL이 아닌 경우: [https://mypage.com/list](https://mypage.com/list) (몇 페이지를 가져와야 하는지 지정되지 않은 경우임)  
>   → URI가 되려면 [https://mypage.com/list?page=2](https://mypage.com/list?page=2) 가 붙어야 한다.

---

### 웹 접근성(Web Accessibility)

웹 접근성: 모든 사용자가 신체적/환경적 조건에 관계 없이 웹에 접근하여 이용할 수 있도록 보장하는 것.

- 신체적 조건: 장애, 고령자 등
- 환경적 조건: 다양한 기기, OS, 웹 브라우저, 저사양 및 저속회선 사용자 등

> - 웹 접근성은 2017년 장애인차별금지법으로 시행/보장되었다.

웹 접근성 준수 시 기대 효과

- 장애인, 고령자 등 사용자 층 확대
- 사회 공헌 및 복지 기업으로 기업 이미지 향상

웹 접근성 국제표준 검사항목(KWCAG) (일부)

- 인식: 적정한 대체 텍스트/ 자막, 수화 제공/ 색에 무관한 콘텐츠 인식
- 운용: 키보드 사용 보장/ 조작 가능(손떨림 대비)/ 응답시간 조절/ 제목 제공(헤딩 태그 등)
- 이해: 주사용 언어로 명시/ 요구에 따른 실행/ 콘텐츠 선형구조
- 견고: 마크업 오류 방지(열고 닫음에 오류 x)

웹 접근성을 위한 대표 기술

- 시멘틱 마크업(강조로 `<b>`보다는 `<strong>` 사용)
- 텍스트를 포함하는 이미지(`alt` 속성)
- 텍스트 명도 대비(W3C는 텍스트와 배경 간 명도 대비를 최소 4.5:1 제공 권장)
- 동영상 실시간 자막
- 자동 완성 기능

---

### HTML5

HTML5

- HTML의 5번째 버전
- 웹의 핵심 마크업 언어
- 비디오, 오디오 등 다양한 부가기능과 멀티미디어 콘텐츠를 액티브X 없이 브라우저에서 쉽게 볼 수 있게 하는 것을 목적

추가된 요소

- 구조적 요소(구역을 나누는 블록 요소인 div 요소를 대신(
  : header, nav, article, section, aside, footer
- 멀티미디어 요소(플러그인 없이 멀티미디어 재생)
  : audio, video, canvas
- 기타: details, figure, figcaption
