# Data Structure & Algorithm

## Table of Contents

Data Structure

- 스택과 큐에 대해 설명해본다면?
- 연결 리스트(Linked List)란?
- 그래프와 트리란?
- 이진 탐색 트리(Binary Search Tree, BST)란?
- 이진 탐색 트리의 연산에 대해 설명해본다면?
- 불균형한 이진 탐색 트리의 검색 연산을 보완하기 위한 방법은?
- 힙이란?
- 힙의 삽입과 삭제 연산에 대해 설명해본다면?
- 우선순위큐를 구현하는 방법에는 어떤 것들이 있을까?

---

## Data Structure

### 스택과 큐에 대해 설명해본다면?

스택

- 가장 마지막에 삽입된 데이터가 가장 먼저 제거되는 자료구조
- 변수 `TOP`이 스택의 가장 위를 가리키며, 이곳을 통해서만 삽입과 삭제가 이뤄진다.
- 삽입/삭제하는 연산 `push`와 `pop`을 메소드로 가진다.
- 활용 예시
  - 웹 브라우저 방문 기록 구현
  - 콜스택(Call Stack)
  - 후위 표기법 계산
  - 수식의 괄호 검사

> - 후입선출(LIFO, Last-In-First-Out)

큐

- 가장 먼저 삽입된 데이터가 가장 먼저 제거되는 자료구조
- 삭제가 진행되는 `front`와 삽입이 진행되는 `rear`를 변수로 가진다.
- 삽입 연산 `enqueue`와 삭제 연산 `dequeue`를 메소드로 가진다.
- 활용 예시
  - 우선순위가 같은 task 간 실행 순서 관리
  - 프로세스 스케줄링
  - BFS 구현

> - 선입선출(FIFO, First-In-First-Out)

---

### 연결 리스트(Linked List)란?

- 연속적인 메모리 위치에 저장되지 않는 선형적인 자료구조
- 포인터(다음 노드에 대한 참조)를 통해 노드(데이터)가 연결된다.

> - 단일 연결 리스트(Single Linked List), 다중 연결 리스트(Doubly Linked List) 등이 존재한다.

장점(배열과의 차이점)

- 배열은 고정된 크기로 할당이 되는 반면, 연결 리스트는 동적으로 노드를 추가할 수 있다.
- 배열은 중간 위치에 삽입, 삭제가 `O(n)`의 시간 복잡도를 가지지만, 연결 리스트는 `O(1)`의 시간 복잡도를 가진다.

> - 배열은 인덱스로 특정 위치의 데이터에 빠르게 액세스할 수 있다. (시간 복잡도: `O(1)`)

단점

- 임의의 데이터에 액세스를 허용하지 않아 순차적으로 탐색해야 한다. (시간 복잡도: `O(n)`)
- 각 노드마다 포인터 값을 위한 메모리 공간이 추가로 필요하다.

---

### 그래프와 트리란?

그래프

- 정점(vertex)과, 정점을 연결하는 간선(edge)으로 구성된 자료구조
- 네트워크 모델이다.

> - 네트워크 모델: 하위 데이터가 여러 개의 상위 데이터를 가질 수 있도록 표현된 데이터 구조
> - 차수(degree): 한 정점에 연결된 간선의 수

> - 방향 그래프(Directed Graph)와 무방향 그래프(Undirected Graph)가 있다.
> - 순환 그래프와 비순환 그래프(: 트리)가 있다.
> - 간선에 비용이나 가중치가 할당된 경우 가중치 그래프(Weighted Graph)라 하며, '네트워크'라고도 한다.

트리

- 사이클이 존재하지 않는(비순환) 그래프
- 계층 모델이다.

> - 계층 모델: 하나의 상위 데이터가 여러 개의 하위 데이터를 가질 수 있도록 표현된 데이터 구조
> - 사이클(cycle): 한 정점에서 출발해 시작한 정점을 다시 돌아오는 경로

> - 정점이 N개인 트리는 항상 N-1개의 간선을 가진다.
> - 트리의 순회(traversal) 방법에는 preorder, inorder, postorder가 있다.

---

### 이진 탐색 트리(Binary Search Tree, BST)란?

- 정렬된 이진 트리
- 노드의 왼쪽 자식 트리에는 노드의 키보다 작은 키를 가지는 노드만 포함하며, 노드의 오른쪽 자식 트리에는 노드의 키보다 큰 키를 가지는 노드만 포함한다.

> - 이진 탐색 트리는 중복된 키를 포함하지 않는다.
> - inorder 순회로 모든 키를 정렬된 순서로 가져올 수 있다.

> - Q. 이진 힙과 이진 탐색 트리의 차이점은? (용도, 연산의 시간 복잡도)

---

### 이진 탐색 트리의 연산에 대해 설명해본다면?

검색

- 루트에서 시작해, 루트보다 작으면 왼쪽 자식 트리에 대해 재귀를 돌리고, 루트보다 크면 오른쪽 자식 트리에 대해 재귀를 돌린다. 일치하는 값을 찾을 때까지 반복한다.
- 시간 복잡도: 이진 탐색 트리가 균형 상태일 경우 `O(logn)`, 불균형 상태일 경우 최악의 경우에 `O(n)`(트리의 높이가 `n`)의 시간 복잡도를 가진다.

> - 균형 상태: 루트로부터, 왼쪽 자식 트리의 높이와 오른쪽 자식 트리의 높이 차이가 1 이하인 상태.

삽입

- 루트에서 시작해, 루트보다 작으면 왼쪽 자식 트리에 대해 재귀를 돌리고, 루트보다 크면 오른쪽 자식 트리에 대해 재귀를 돌린다.
- 리프 노드에 도착한 후, 노드보다 작으면 왼쪽에, 노드보다 크면 오른쪽에 리프 노드로 삽입한다.

삭제

1. 삭제할 노드가 리프 노드인 경우
   - 해당 노드를 삭제한다.
2. 삭제할 노드에게 자식 노드가 1개 있는 경우
   - 노드를 삭제한 후, 자식 노드를 삭제한 노드의 부모 노드에 연결한다.
3. 삭제할 노드에게 자식 노드가 2개 있는 경우
   - successor 노드(후임자 노드)를 찾는다. successor 노드는 왼쪽 자식 트리의 가장 오른쪽 노드, 혹은 오른쪽 자식 트리의 가장 왼쪽 노드이다. (정하기 나름)
   - 삭제할 노드와 successor 노드를 swap한다.
   - 삭제하려 했던 노드를 삭제한다.

---

### 불균형한 이진 탐색 트리의 검색 연산을 보완하기 위한 방법은?

자가 균형 이진 탐색 트리를 활용하면 된다.

- 자가 균형 이진 탐색 트리란, 삽입과 삭제가 일어나는 경우에 자동으로 균형 상태를 유지하는 이진 탐색 트리를 말한다.
- 자가 균형 이진 탐색 트리에는 AVL 트리, 레드 블랙 트리, B tree 등이 있다.

---

### 힙이란?

- 최대값, 최소값을 빠르게 찾아내기 위해 고안된 완전 이진 트리.
- 힙의 종류에는 최대 힙(max heap)과 최소 힙(min heap)이 있다. 최대 힙은 부모 노드의 키 값이 자식 노드의 키 값보다 크거나 같다. 최소 힙은 부모 노드의 키 값이 자식 노드의 키 값보다 작거나 같다.
- 배열을 통해 쉽게 구현할 수 있다.

> - 힙은 우선순위큐를 구현하는 데 사용될 수 있다.
> - 힙은 중복된 값을 허용한다. 반면 이진 탐색 트리는 중복된 값을 허용하지 않는다.
> - 형제 노드 간에는 우선순위의 대소관계가 정해지지 않는다. 이러한 특성을 '반정렬 상태'라고 한다.
> - 구현을 쉽게 하기 위해 배열의 첫번째 인덱스(`[0]`)은 사용되지 않는다.
> - 힙은 일반적으로 이진 힙을 가리킨다.

> - 이진 트리: 각각의 노드가 최대 2개의 노드를 가지는 트리.
> - 완전 이진 트리: 마지막 레벨을 제외한 모든 레벨이 완전히 채워져 있으며, 마지막 레벨의 모든 노드는 가능한 왼쪽에 위치한 이진 트리.

---

### 힙의 삽입과 삭제 연산에 대해 설명해본다면?

삽입

- 배열의 마지막에 새로운 데이터를 삽입한다.
- 삽입된 데이터의 우선순위가 부모 노드의 값보다 높지 않을 때까지 swap한다. (: `shiftUp()`)
- `O(logN)`의 시간 복잡도를 가진다.

삭제

- 배열의 첫번째 원소와 마지막 원소를 swap한다.
- 배열의 마지막 원소를 삭제한다.
- 배열의 첫번째 원소에 대해, 우선순위가 자식 노드의 값보다 낮지 않을 때까지 swap한다. (: `shiftDown()`)
- `O(logN)`의 시간 복잡도를 가진다.

---

### 우선순위큐를 구현하는 방법에는 어떤 것들이 있을까?

- 배열, 연결 리스트, 힙으로 구현할 수 있다.
- 배열과 연결 리스트는 삭제 연산의 시간 복잡도에서 우위를 점하지만, 힙의 삽입 연산 시간 복잡도가 월등하기 때문에 힙으로 구현한다.

배열

- 삽입: 위치를 찾기 위해 순차적으로 데이터를 순회해야 하며, 중간에 삽입할 경우 원소들을 뒤로 하나씩 미뤄야 하므로 `O(n)`의 시간 복잡도를 가진다.
- 삭제: 가장 첫번째 원소를 반환하면 되므로 `O(1)`의 시간 복잡도를 가진다.

연결 리스트

- 삽입: 위치를 찾기 위해 순차적으로 데이터를 순회해야 하므로 `O(n)`의 시간 복잡도를 가진다.
- 삭제: 가장 첫번째 노드의 값을 반환하면 되므로 `O(1)`의 시간 복잡도를 가진다.

힙

- 삽입과 삭제: 우선순위에 따른 위치를 탐색할 때 부모와 자식 간의 비교만 이뤄진다. 트리의 높이가 증가할 때마다 저장 가능한 데이터의 개수가 2배씩 증가하므로, 삽입과 삭제 모두 `O(log2n)`의 시간 복잡도를 가진다.

> - 우선순위큐: 들어간 순서와 상관 없이 우선순위가 높은 데이터 먼저 삭제되는 큐

---
